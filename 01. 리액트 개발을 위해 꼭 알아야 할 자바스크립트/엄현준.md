# 1. 리액트 개발을 위해 꼭 알아야 할 JS

> 리액트 코드 작성 및 이해를 위한 최소한의 자바스크립트

## 1.1 자바스크립트의 동등 비교

> 리액트 렌더링에 대한 이해를 위해 필요

### 1.1.1 자바스크립트의 데이터 타입

> 원시 타입, 객체 타입에 대한 비교

**_undefined vs null_**

- typeof(undefined)는 'undefined'
- typeof(null)은 'object' 라는 점 (이전 코드와의 호환성 때문)

### 1.1.3 자바스크립트의 또 다른 비교 공식, Object.is

**_=== vs Object.is_** <br>
Object.is가 좀 더 이해 가능한 비교 (몇가지 특이 케이스를 추가로 만족)

```js
-0 === +0; // true
Object.is(-0, +0); // false

Number.NaN === NaN; // false
Object.is(Number.NaN, NaN); // true

NaN === 0 / 0; // false -> 0/0의 결과는 NAN이다.
Object.is(NaN, 0 / 0); // true
```

### 1.1.4 리액트에서의 동등 비교

> 리액트의 메모제이션은 depth1만 비교하는 얕은 비교를 하기 때문에 객체의 depth가 2가 넘어가면, 메모제이션이 되지 않음. 얕은 비교를 하는 이유는 성능때문

```js
function is(x: any, y: any) {
  return (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y);
}
```

**_(x !== 0 || 1 / x === 1 / y)_**

- +0과 -0을 비교하기 위함
- +0 === -0은 true
- 1 / 0이 Infinity가 되고, 1 / -0은 -Infinity가 되는 성질을 이용

**_(x !== x && y !== y)_**

- NaN(Not-a-Number)을 비교하기 위함
- NaN === NaN은 false
- x !== x와 y !== y로 두 값이 각각 NaN인지 확인

## 1.2 함수

### 1.2.3 다양한 함수 살펴보기

1. **즉시 실행 함수**

   ```jsx
   (function (a, b) {
     return a + b;
   })(
     10,
     20
   )((a, b) => {
     return a + b;
   })(10, 24);
   ```

- 함수를 정의하고 즉시 실행되는 함수
- 재호출 불가 → 일반적으로 이름을 붙이지 않는다.
- 다시 호출 안된다는 점을 확실히 할 수 있음.

<br>

2. **고차 함수**

   ```jsx
   const doubledArray = [1, 2, 3].map((item) => item * 2); // 함수가 매개변수로 쓰였다: (item) => item * 2

   const add = function (a) {
     return function (b) {
       return a + b;
     };
   };

   add(1)(3); // 4
   ```

- 함수를 받아 → 함수를 리턴하거나 값을 리턴
- 이를 활용한 컴포넌트를 받아 컴포넌트를 반환하는 고차 컴포넌트(HOC)

### 1.2.4 함수를 만들 때 주의해야 할 사항

1. **부수 효과(side-effect) 최대한 억제하기**

- 부수 효과: 함수 내의 작동으로 인해 함수가 아닌, 함수 외부에 영향을 끼치는 것을 의미
- 순수 함수: 부수 효과가 없는 함수
- 비순수 함수:부수 효과가 있는 함수
- useEffect 최소화하기

<br>

2. **함수 가능한 작게 만들기**

- 하나의 함수는 하나의 일만

<br>

3. **누구나 이해할 수 있는 이름 붙이기**

- 한글로 이름 붙이는 것도 괜춘
  - Terser 사용하기(맹글링: 코드를 컴파일러가 이해할 수 있는 수준으로 단순화, 및 압축)
  - 다만 제대로 작동 안하는 경우도 있으므로 주의 필요
- useEffect나 useCallback의 콜백함수에 이름 붙여주기 (가독성 측면에서 도움이 됨)
  ```jsx
  useEffect(function apiRequest() {
    // 블라블라
  }, []);
  ```

## 1.4 클로저

**클로저에 의존하는 기술**

1. 함수 컴포넌트의 구조와 작동 방식
2. 훅의 원리
3. 의존성 배열 등

<br>

### 1.4.2 변수의 유효 범위, 스코프

- 변수의 유효 범위(scope)

1. **전역 스코프**
2. **함수 스코프**
   1. 자바스크립트는 기본적으로 함수 레벨 스코프
      - (var → const랑 let은 블록 스코프이지만 es6에 들어옴)
      - {}가 아닌 함수가 스코프를 결정함.

<br>

### 1.4.4 주의할 점

클로저는 선언적 환경을 기억하는 비용이 들기 때문에 주의가 필요

## 1.7 선택이 아닌 필수, 타입스크립트

### 1.7.1 타입스크립트란?

> 문법에 타입을 가미한 것.

- 자바스크립트 = 동적 타입의 언어 → 실행후에야 에러를 확인할 수 있음

<br>

**해결방법**

1. 자바스크립트 타입 체크로 문제 방지

   - 너무 번거로움. 코드가 길어짐.

2. 타입스크립트
   - 정적으로 빌드 타임에 타입 체크 가능
   - 다만 enum, 제네릭 등 다양한 개념 때문에 어렵게 느껴질 수 있음.

### 1.7.2 리액트 코드를 효과적으로 작성하기 위한 타입스크립트 활용법

1. **any 대신 unknown을 사용하자**

   ```js
   function doSomething(callback: unknown) {
     if (typeof callback === "function") {
       callback();
       return;
     }

     throw new Error("callback은 함수여야 합니다.");
   }
   ```

- **unknown**

  - 모든 값을 할당할 수 있음.
  - any와 다르게 type을 좁혀야 사용할 수 있음(type narrowing)

- **never**
  - 어떠한 타입도 들어올 수 없음
  - props는 없지만, state가 존재하는 상황에서 빈 props에 아무것도 받아들이지 않는다는 뜻으로 사용 가능

2. **타입 가드를 적극 활용하자**
3. **제네릭**

- 제네릭은 함수나 클래스 내부에서 단일 타입이 아닌 다양한 타입에 대응할 수 있도록 도와주는 도구

4. **인덱스 시그니처**

- 객체의 키를 정의하는 방식
