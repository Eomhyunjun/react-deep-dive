## ✨ 자바스크립트의 데이터 타입

- 원시 타입
    - null → typeof null === `object`
    - undefined
    - boolean
    - bigInt
    - string
    - number
    - symbol
- 객체 타입
    - Object === 참조 타입 (Reference Type)
        
        객체는 값을 저장하는것이 아닌, 참조를 저장한다. 그렇기 때문에 같은 값을 가지고있더라도, 다른 참조를 바라보기 때문에 두 객체가 동등하지 않을 수 있다.
        

## ✨ Object.is 와 “==” “ === “

- 세가지 모두 동등한지를 연산하기 위해 사용된다.
    - == : 양쪽의 값의 type이 다르다면 강제로 형변환을해서 같은 type으로 바꾼 후 비교한다
    - === : 강제 형변환을 하지 않는다.
    - [Object.is](http://Object.is) : === 연산에서 NaN === NaN 과 같은 값이 false로 나오기 때문에 좀 더 사용자가 기대하는 방식으로 결과를 받을 수 있도록 하기 위해 만들어졌다.
- React에서는 객체끼리도 동일한지 비교하기위해서 shallowEqual 이라는 함수를 통해서 키와 값을 얕은 비교를 통해서 확인한다. 역시 만약 키의 값에 객체가 들어가있다면 is 연산을 통해서 비교하기 때문에 두 객체의 키와 밸류가 모두 같더라도 참조가 다르다면 false가 나온다.

```jsx
// 간단한 비교 예제들

const hello = {
	val : 'hello'
}
const hi = {
	val : 'hello'
}
const s1 = 'hello'
const s2 = 'hello'

console.log(typeof null) // 'object'
console.log(null === null) // true null은 0 이라는 주소를 가르키고 있어서?
console.log(s1 === s2) // true, String 은 원시 타입이다. 
console.log(hello === hi) // false, hello, hi는 Object 타입으로 참조를 비교한다.
console.log(Object.is(hello, hi)) // false
console.log(NaN === NaN) // false
console.log(Object.is(NaN, NaN)) // true
```

## ✨ 호이스팅

- 인터프리터가 코드를 실행하기 전에 함수, 변수, 클래스 또는 임포트(import)의 선언문을 해당 범위의 맨 위로 끌어올리는 것처럼 보이는 현상
- 인터프리터가 실행되기전에 변수와 함수의 메모리 공간을 미리 할당하는 것
- let, const, class 는 호이스팅이 되지않는것으로도 보는데 TDZ에 속해서 선언전에 접근할 경우 에러를 발생시키기 때문이다. var 같은 경우에는 선언전에 접근가능하다, undefined로 초기화되어 있다.

- 장점 : 함수의 위치와 관계없이 어디서든 접근 가능하다. 함수의 선언을 뒤에 하고, 앞에서 해당 함수를 사용하여도 문제가 없다.
- 단점 : 해당 함수가 어디에 정의되어있는지 찾는 어려움등 관리에 어려움이 있을 수 있다.

## ✨ 화살표함수  vs 일반 함수

```jsx
function normal() {
	console.log('일반 함수')
}

const arrowFun = () => {
	console.log('화살표 함수'
}
```

둘의 가장 큰 차이 는 This Binding 이다. 일반 함수로 호출되고 사용되면 해당 함수 내부의 this는 전역객체를 가리킨다. 화살표 함수의 경우에는 이와 다르게 상위 스코프의 this를 그대로 따르게 된다. 바벨로 트랜스파일링 했을 때 이를 확인할 수 있다.

- This : 자신이 속한 객체나 생성할 인스턴스를 가리키는 값.
- 화살표 함수는 트랜스파일시 내부의 this 값이 _this값으로 바뀌고 선언된 환경의 상위 스코프의 this 값을 _this에 저장해놓게 된다.

## ✨ 클로져

- 함수와 함수가 선언된 어휘적(Lexical) 환경의 조합. 즉 함수가 선언된 환경을 기억하고, 그 환경을 사용한다.
- JS는 함수레벨 스코프를 이용한다. 즉 { } 와 같은 블록레벨 스코프를 사용하지 않기 때문에 블록레벨 스코프를 사용하기 위해서는 var이 아닌 let 과 const 를 사용해야한다.
- 함수 내부의 변수를 찾아 갈 때, 자신의 스코프에서 찾고 만약에 찾지 못할경우의 상위 환경을 따라 찾아가면서 해당 변수를 찾아간다.

```jsx
for (var i = 0; i < 5; ++i) {
	setTimeout(() => {
		console.log(i)
	}, i * 1000)
}

// 5초후 5, 5, 5, 5, 5 가 출력된다.
// var이 함수스코프기 때문에 모든 setTimeout 내부의 함수가 바라보는 i가 동일하기 때문에 생기는 문제
// let은 블록스코프이기 때문에 모든 setTimeout 함수가 바라보는 i가 달라지고 원하는 대로 동작한다.

for (let i = 0; i < 5; ++i) {
	setTimeout(() => {
		console.log(i)
	}, i * 1000)
}
```

 

- 클로져를 사용하는 이유 ?
    - private Method를 흉내낼 수 있다. useState 에서 값에 접근해서 바꿀 수 있는 setState 함수를 사용해서 조정하는 것
- 클로져를 사용할 때 주의해야하는 점
    - 상위의 환경을 모두 기억한다는것은 큰 비용이 발생할 수 있다. 만약에 해당 클로저 함수가 상위에 엄청나게 큰 배열을 참조하고 있다면. 이를 기억하고있어야하고 결과적으로 메모리의 용량을 불필요하게 잡아먹고있는 결과가 발생할 수 있다.

## ✨ 이벤트 루프와 비동기 통신

- 자바스크립트는 싱글 스레드로 동작한다. 즉 한번에 한가지 일밖에 처리하지 못한다. 이를 도와주기 위해 이벤트 루프라는 장치를 사용해서 비동기 작업을 가능하게 한다.
- 자바 스크립트는 하나의 호출 스택 (call stack) 을 가지고 있다. 실행해야할 함수들을 순차적으로 담아 놓고 이를 하나씩 동기적으로 실행한다.
- 네트워크 요청과 setTimeout과 같은 비 동기 함수들은 웹 API를 통해서 처리된다, 해당 요청이 처리되고 나면 이벤트 루프의 태스크큐에 콜백함수들이 등록된다.
- 이벤트 루프는 마이크로 큐와 매크로 큐로 이루어져있다. 콜 스택이 비어있게 되면 마이크로 큐에 있는 콜백함수들을 모두 처리하고 그 다음 매크로 큐의 콜백함수들을 처리한다. 이 과정에서 매크로 큐의 콜백함수를 실행하기 전에 렌더링이 일어난다.
- 마이크로 큐에는 Promise, process.nextTick() 의 콜백함수들이 들어가고, 매크로 큐에는 setTimeout, setInterval의 콜백함수들이 들어간다.
