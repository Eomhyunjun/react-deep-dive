# 2장 리액트 핵심 요소 깊에 살펴보기

## 2.1 JSX란?

**JSX**는 **`JavaScript XML`**의 약자로, JavaScript에서 HTML을 작성할 수 있게 해주는 문법

### 2.1.1 JSX의 정의

4가지 컴포넌트로 구성되어 있다.

- **JSXElement**
    
    : Html의 태그나 커스텀 컴포넌트를 나타내는 요소
    
- **JSXAttributes**
    
    : JSXElement에 전달되는 속성 (className, id, style 등)
    
- **JSXChildren**
    
    : JSXElement의 자식 요소들, 다른 컴포넌트나 텍스트 등
    
- **JSXStrings**
    
    : 문자열, JSXText
    

### 2.1.2 JSX 예제

```jsx
const ComponentA = <A>안녕하세요.</A>

const ComponentB =(
	<A>
		안녕하세요.
		<B text="리액트 딥다이브" />
	</A>
)
```

### 2.1.3 JSX는 어떻게 자바스크립트에서 변환될까?

- Babel과 같은 **`트랜스파일러`**가 JSX를 JavaScript 코드로 변환
    
    플러그인 : @bebel/plugin-transform-react-jsx
    
- JSX가 `React.createElement` 함수를 통해 자바스크립트로 변환

## 2.2 가상 DOM과 리액트 파이버

### 2.2.1 가상 DOM과 브라우저 렌더링 과정

1. 브라우저가 사용자가 요청한 주소 방문, HTML 파일 다운로드
2. 브라우저 렌더링 엔진이 HTML을 파싱하여 **`DOM 트리`** 구성
3. 2번 과정에서 CSS파일 다운로드
4. CSS를 파싱하여 **`CSSOM 트리`** 구성
5. 브라우저는 2번에서 만든 DOM 노드 순회
    1. 모든 노드 방문 X, **사용자의 눈에 보이는 노드만 방문**
6. 5번에서 방문한 노드를 배상으로 CSSOM 정보를 찾고 노드에 CSS스타일 적용
    1. **`레이아웃(layout, reflow)`** : 각 노드가 브라우저 화면의 **어느 좌표에 나타나야 하는지 계산**하는 과정 (**페인팅 과정도 반드시 거침**)
    2. **`페인팅(painting)`** : **레이아웃을 거친 노드**에 색과 같은 실제에 **유효한 모습**을 그리는 과정

### 2.2.2 가상 DOM의 탄생 배경

- DOM의 성능 문제 (변경 할 때 마다 다시 계산하고 렌더링 해야함)
- DOM을 직접 조작할 때 마다 **전체 페이지가 다시 그려져**서 느려짐
- DOM을 직접 조작하여 상태변화를 할 경우, 복잡성 증가

**React의 가상 DOM 도입**

- 가상 DOM은 메모리 상에서 DOM의 사본을 유지하며, 상태가 변경되면 가상 DOM을 먼저 업데이트 한다.
- 가상 DOM은 변경사항을 추적하여 효율적인 방법으로 **실제 DOM에 반영**한다. (실제 DOM에 직접 접근 X)
    
    = 재조정 (reconciliation)
    
- 실제 DOM 전체를 다시 그리지 않기에 반응성이 뛰어나다.

### 2.2.3 가상 DOM을 위한 아키텍쳐, 리액트 파이버

**리액트 파이버**

: 리액트의 새로운 **`재조정(Reconciliation) 엔진`** (react 16에서 도입)

- 기존의 React Stack → 동기적, 컴포넌트 트리가 복잡할수록 렌더링 소요 시간 증가
- 파이버는 작업을 더 작은 단위로 나누어서 남은 작업 저장, 다음 사이클에서 이어서 진행
- 더 부드러운 사용자 경험 제공

**리액트 파이버 트리**

- 업데이트 상태를 저장하고 처리할 수 있는 능력을 가짐
- 파이버 트리는 컴포넌트 트리의 각 컴포넌트, 상태, props, 이벤트 핸들러, 렌더링 결과 등을 가짐
- 연결리스트 형태로 구성되어 부모, 자식, 형제에 대한 참조를 가져 탐색이 빠름
- https://codepen.io/ejilee/pen/eYMXJPN

**파이버의 작업 순서**

1. 리액트는 `beginWork()` 함수를 실행하여 파이버 작업 수행 (자식이 없는 파이버를 만날 때 까지)
2. 1전번 작업이 끝났다면 `completeWork()` 실행하여 파이버 작업 완료
3. 형제가 있다면 형제로 넘어감
4. 2,3번이 모두 끝났다면 `return`으로 돌아가 작업 완료를 알림

## 2.3 클래스 컴포넌트와 함수 컴포넌트

### 2.3.1  클래스 컴포넌트

클래스를 선언하고 extends 해야만 한다.

- **React.Component**
- **React.PureComponent**

```jsx
class MyComponent extends React.Component {
    state = { count: 0 };

    componentDidMount() {
        console.log('Mounted');
    }

    render() {
        return <div>{this.state.count}</div>;
    }
}
```

### 2.3.2 함수 컴포넌트

화살표 함수 또는 일반 함수

**Hooks** (16.8 도입)

함수 컴포넌트의 상태관리와 생명주기 메서드 사용 가능 `useState`, `useEffect` 

```jsx
function MyComponent() {
    const [count, setCount] = useState(0);

    useEffect(() => {
        console.log('Mounted');
    }, []);

    return <div>{count}</div>;
}
```

### 2.3.3 함수 컴포넌트 vs 클래스 컴포넌트

클래스 컴포넌트는 데이터 추적이 어렵고 내부 로직 재사용이 어렵다. 최적화도 어려움

클래스 컴포넌트의 생명주기 메서드는 함수 컴포넌트에 존재하지 않는다

- 함수형 → props, state를 기준으로 렌더링
- 클래스 → this 기준으로 렌더링

## 2.4 렌더링은 어떻게 일어나는가?

### 2.4.1 리액트의 렌더링이란?

리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이 현재 자신이 갖고 있는 props와 state의 값을 기반으로 어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에게 제공할 것인지 계산하는 일련의 과정

### 2.4.2 리액트의 렌더링이 일어나는 이유

1. 최초 렌더링
2. 리렌더링
    1. 클래스 컴포넌트의 setState 변경
    2. 함수 컴포넌트의 useState의 배열 두번째 요소 setter가 실해오디는 경우
    3. 함수 컴포넌트의 useReducer()의 두번째 요소인 dispatch가 실행되는 경우
    4. 컴포넌트의 key props가 변경되는 경우

### 2.4.3 리액트의 렌더링 프로세스

컴포넌트의 루트에서 아래로 내려가면서 업데이트가 필요한 모든 컴포넌트를 찾는다.

업데이트가 필요한 컴포넌트를 발견하면 

클래스 컴포넌트 : render() 함수 실행

함수 컴포넌트 : FunctionComponent() 호출 후 결과물 저장

### 2.4.4 렌더와 커밋

- **렌더 단계(Render Phase)**: 변경사항을 계산하지만, 아직 실제 DOM에는 반영되지 않음.
- **커밋 단계(Commit Phase)**: 변경 사항을 실제 DOM에 적용하여 사용자에게 보여주는 과정.

<aside>
💡

리액트의 렌더링이 일어난다고 무조건 DOM 업데이트가 일어나는 것은 아니다.

</aside>

### 2.4.5 일반적인 렌더링 시나리오 살펴보기

상태변경, props변경, 조건부 렌더링 등등..

## 2.5 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션

메모이제이션 : 함수나 컴포넌트의 연산 결과를 **`캐시`**해, 동일한 입력에 대해 **`반복적으로 연산하지 않도록 하는 최적화 기법`**

### 2.1.1 주장 1 - 섣부른 최적화는 독이다. 꼭 필요한 곳에만 메모이제이션을 추가하자

모든 연산을 메모이제이션하면 메모리 사용량이 늘어날 수 있다. 따라서, 메모이제이션은 진짜 성능 문제를 일으키는 부분에만 적용하는 것이 좋다

### 2.1.2 주장 2 - 렌더링 과정의 비용은 비싸다. 모조리 메모이제이션 해 버리자.

컴포넌트가 자주 렌더링되거나, 함수의 연산이 무거운 경우, 메모이제이션을 성능 향상이 가능

- `React.memo`, `useMemo`, `useCallback`
