# 2.1 JSX란?

JSX는 리액트가 등장하면서 페이스북에서 소개한 새로운 구문이지만 반드시 리액트에서만 사용하라는 법은 없다.  XML과 유사한 내장형 구문이며 리액트에 종속적이지 않은 독자적인 문법으로 보는 것이 옳다. JSX는 ECMAScript라고 불리는 자바스크립트 표준의 일부는 아니다. JSX는 반드시 트랜스파일러를 거쳐야 비로소 자바스크립트 런타임이 이해할 수 있는 자바스크립트 코드로 변환된다.
JSX는 HTML, XML 외에도 다른 구문으로 확장될 수 있게끔 고려돼 있으며 최대한 구문을 간결하고 친숙하게 사용할 수 있도록 서례돼 앴다.
**자바스크립트 내부에서 표현하기 까다로웠던 XML 스타일의 트리 구문을 작성하는 데 많은 도움을 주는 새로운 문법이라고 볼 수 있다.**

## 2.1.1 JSX의 정의


**JSXElement**
HTML의 Element와 비슷한 역할을 한다.

``` jsx
<Element Attributes(optional)></Element> // JSXOpeningElement, JSXClosingElement
<Element Attributes(optional)/> // JSXSelfClosingElement 요소가 시작되고 스스로 종료되는 형태. 자식을 포함할 수 없다.
<></> // JSXFragment 아무런 요소가 없는 형태
```

**JSXElementName**
JSXelement 요소 이름으로 쓸 수 있는 것을 의미한다.

- JSXIdentifier: JSX 내부에서 사용할 수 있는 식별자.
자바스크립트와 마찬가지로 숫자로 시작할 수 없고, 특수문자로는 $와 _로만 시작할 수 있다.

``` jsx
function Valid1(){
  return <$></$>
}
```

- JSXNamespacedName: ':'을 통해 서로 다른 식별자를 이어준다. 하나까지만!
``` jsx
function valid() {
  return <foo:bar></foo:bar>
}
```

- JSXMemberExpression: '.'을 통해 서로 다른 식별자를 이어준다. 여러개도 가능!

``` jsx
function valid2(){
  return <foo.bar.baz></foo.bar.baz>
}
```

**JSXAttributes**

JSXElement에 부여할 수 있는 속성

**JSXChildren**

JSXElement의 자식값을 나타낸다.

**JSXStrings**

\을 HTML처럼 이스케이프 문자열로 처리하고 있지않다.

## 2.1.3 JSX는  어떻게 자바스크립트에서 변환될될까?

``` jsx
// ❌ props 여부에 따라 children 요소만 달라지는 경우
// 굳이 번거롭게 전체 내용을 삼항 연산자로 처리할 필요가 없다.
// 이 경우 불필요한 코드 중복이 일어난다.
function TextOrHeading({
  isHeading,
  children,
}: PropsWithChildren<{ isHeading: boolean }>) {
  return isHeading ? (
    <h1 className="text">{children}</h1>
  ) : (
    <span className="text">{children}</span>
  );
}

// ⭕ JSX가 변환되는 특성을 활용한다면 다음과 같이 간결하게 처리할 수 있다.
import { createElement } from 'react';

function TextOrHeading({
  isHeading,
  children,
}: PropsWithChildren<{ isHeading: boolean }>) {
  return createElement(
    isHeading ? 'h1' : 'span',
    { className: 'text' },
    children,
  );
}

```

JSX 반환값이 결국 React.createEelement로 귀결된다는 사실을 파악한다면 쉽게 리팩터링할 수 있다.
JSX는 대부분의 경우 편리하고 간결하게 컴포넌트를 작성하는 데 많은 도움을 주지만 앞선 예제처럼 때에 따라서는 createElement를 사용해 컴포넌트를 구성하는 편이 더 효율적일 수 있다.

# 2.2 가상 DOM과 리액트 파이버

## 2.2.2 가상 DOM의 탄생 배경

브라우저의 렌더링은 아주 많은 비용이 드는데, 렌더링이 완료된 이후에도 사용자의 인터랙션으로 웹페이지가 변경되는 상황도 고려해야한다.

가상 DOM은 리액트가 관리하는 가상의 DOM이다. 웹페이지가 표시해야 할 DOM을 일단 메모리에 저장하고 리액트가 실제 변경에 대한 준비가 완료됐을 때 실제 브라우저의 DOM에 반영한다.

## 2.2.3 가상 DOM을 위한 아키텍처, 리액트 파이버

가상 DOM과 렌더링 과정 최적화를 가능하게 해주는 것이 바로 리액트 파이버이다.

**리액트 파이버란?**
리액트에서 관리하는 자바스크립트 객체다. 가상 DOM과 실제 DOM을 비교해 변경 사항을 수집하며, 이 둘 사이에 차이가 있으면 변경에 관련된 정보를 가지고 있는 파이버를 기준으로 화면에 렌더링을 요청하는 역할을 한다.
이러한 모든 과정은 **비동기**로 일어난다. 파이버는 하나의 작업 단위로 구성돼어 있고, 리액트는 이를 하나씩 처리하고 finishedWork()라는 작업으로 마무리한다. 그리고 이 작업을 커밋해 실제 브라우저 DOM에 가시적인 변경사항을 만들어낸다.

1. 렌더 단계에서 리액트는 사용자에게 노출되지 않는 모든 비동기 작업을 수행한다. 이 단계에서 파이버의 작업(우선순위를 지정하거나 중지시키거나 버리는)이 일어난다.
2. 커밋 단계에서는 DOM에 실제 변경사항을 반영하기 위한 작업(commitWork())가 실행되는데 이는 동기식으로 일어나고 중단될 수도 없다.

즉, 렌더링단계에서는 가상돔을 비교하고 커밋단계에서는 실제 DOM을 업데이트한다.

파이버는 컴포넌트가 최초로 마운트되는 시점에 생성되어 이후에는 가급적이면 재사용된다.

**리액트 파이버 트리**

리액트에는 현재 모습을 담은 파이버 트리, 작업중인 상태를 나타내는 workInProgress트리가 있다. 리액트 파이버의 작업이 끝나면 리액트는 단순히 포인터만 변경해 workInProgress트리를 현재 트리로 바꾼다. (더블 버퍼링)


# 2.3 클래스 컴포넌트와 함수 컴포넌트

## 2.3.1 클래스 컴포넌트

``` jsx
interface SampleProps {
  required?: boolean
  text: string
}

interface SampleState {
  count: number
  isLimited?: boolean
}

// Component에 제네릭으로 props, state를 순서대로 넣어준다.
class SampleComponent extends React.Component<SampleProps, SampleState> {
  private constructor(props: SampleProps){
    super(props)
    this.state = {
      count : 0,
      isLimited : false,
    }
  }
  
  // render에서 이 컴포넌트가 렌더링할 내용을 정의한다.
  pbulic render() {
    const {
      props : { required, text},
      state : { count, isLimited },
    } = this
   }
  return <></>
}
```
- constructor() : 컴포넌트가 초기화되는 시점에 호출되어 state를 초기화할 수 있다.
- state : 클래스 내부 컴포넌트에서 관리하는 값. 항상 객체여야 하며 변화가 있을 때마다 리렌더링이 발생한다.
- 메서드  : 렌더링 함수 내부에서 사용되는 함수이며 DOM에서 발생하는 이벤트와 함께 사용된다.

**클래스 컴포넌트의 생명주기 메서드**

먼저 생명주기 메서드가 실행되는 시점은 크게 3가지로 나눌 수 있다.

- 마운트 : 컴포넌트가 마운팅(생성)되는 시점
- 업데이트 : 이미 생성된 컴포넌트의 내용이 변경(업데이트)되는 시점
- 언마운트 : 컴포넌트가 더 이상 존재하지 않는 시점

render()
이 함수는 컴포넌트가 UI를 렌더링하기 위해 쓰이며 마운트와 업데이트 과정에서 렌더링이 일어난다.
이 render() 함수는 항상 순수해야하며 부수효과가 없어야한다


![](https://velog.velcdn.com/images/lyssoi/post/16201283-6009-46ff-937e-c04c1ac64cf5/image.png)

**클래스 컴포넌트의 한계**

- 데이터 흐름을 추적하기 어렵다 : 서로 다른 여러 메서드에서 state의 업데이트가 일어날 수 있고, 코드 작성 시 메서드의 순서가 강제돼 있는 것이 아니기 때문에 읽기가 어렵다.
- 애플리케이션 내부 로직의 재사용이 어렵다 : 공통 로직이 많아질수록 이를 감싸는 고차 컴포넌트 내지는 props가 많아지는 래퍼 지옥에 빠져들 위험성이 커진다.
- 기능이 많아질수록 컴포넌트의 크기가 커진다
- 클래스는 함수에 비해 상대적으로 어렵다
- 코드 크기를 최적화하기 어렵다.

## 2.3.3 함수 컴포넌트 vs 클래스 컴포넌트

**생명주기 메서드의 부재**

클래스 컴포넌트의 생명주기 메서드가 함수 컴포넌트에서는 존재하지 않는다. 함수 컴포넌트는 props를 받아 단순히 리액트 요소만 반환하는 함수인 반면, 클래스 컴포넌트는 render 메서드가 있는 React.Component를 상속받아 구현하는 자바스크립트 클래스 이기 때문이다.
반면 함수 컴포넌트는 useEffect를 활용해 생명주기 메서드를 비슷하게 구현할 수 있다.
함수 컴포넌트는 렌더링이 일어날 때마다 그 순간의 값인 props와 state를 기준으로 렌더링된다. 반면 클래스 컴포넌트는 시간의 흐름에 따라 변화하는 this를 기준으로 렌더링이 일어난다.

**클래스 컴포넌트를 공부해야 할까?**
리액트의 오랜 역사 동안 많은 코드들이 클래스 컴포넌트로 작성됐으며 이러한 흐름을 알기 위해서는 어느 정도의 클래스 컴포넌트에 대한 지식도 필요하다.

# 2.4 렌더링은 어떻게 일어나는가?

## 2.4.1 리액트의 렌더링이란?

리액트에서의 렌더링이란 리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이 현재 자신이 갖고 있는 props와 state의 값을 기반으로 어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에게 제공할 것인지 계산하는 일련의 과정을 말한다.

## 2.4.2 리액트의 렌더링이 일어나는 이유

1. 최초 렌더링
2. 리렌더링 :
	- 클래스 컴포넌트의 setState가 실행되는 경우
    - 함수 컴포넌트의 useState()의 두번째 배열 요소인 setter가 실행되는 경우
    - 함수 컴포넌트의 useReducer()의 두 번째 배열 요소인 dispatch가 실행되는 경우
    - 컴포넌트의 key props가 변경되는 경우: 리액트에서 key는 명시적으로 선언되어 있지 않더라도 모든 컴포넌트에서 사용할 수 있는 특수한 props다. key는 리렌더링이 발생하는 동안 형제 요소들 사이에서 동일한 요소를 식별하는 값이다.
   
   
## 2.4.3 리액트의 렌더링 프로세스

렌더링 프로세스가 시작되면 리액트는 컴포넌트의 루트에서부터 차근차근 아래ㅉ고으로 내려가면서 업데이트가 필요하다고 지정돼 있는 모든 컴포넌트를 찾는다. 업데이트가 필요한 컴포넌트를 발견하면, 함수컴포넌트의 경우 FunctionComponent() 그 자체를 호출한 뒤에 그 결과물을 저장한다.

## 2.4.4. 렌더와 커밋

렌더 단계는 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업을 말한다. 여기서 비교하는 것은 크게 type, props, key다. 이 세 가지 중 하나라도 변경된 것이 있으면 변경이 필요한 컴포넌트로 체크해 둔다.
커밋 단계는 렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정을 말한다.
리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는 것은 아니다. 변경 사항을 계산했는데 아무런 변경 사항이 감지되지 않는다면 이 커밋 단계는 생략될 수 있다.
렌더링은 동기식으로 작동했지만, 동시성 렌더링이 리액트 18에서 도입됐다.

## 2.4.5 일반적인 렌더링 시나리오 살펴보기

별도로 렌더링을 피하기 위한 조치가 돼 있지 않는 한 하위 모든 컴포넌트에 영향을 미친다. 부모가 변경됐다면 props가 변경됐는지와 상관없이 무조건 자식 컴포넌트도 리렌더링된다.
이 때, 하위 컴포넌트를 메모로 래핑하면 렌더링이 일어나지 않는다. 렌더 단계에서 컴포넌트 비교를 거쳤지만 memo로 선언한 덕분에 props가 변경되지 않으면 렌더링이 생략되므로 커밋 단계도 생략된 것이다.

# 2.5 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션


## 2.5.1 주장1 : 꼭 필요한 곳에만 메모이제이션을 추가하자

메모이제이션도 비용이 드는 작업이므로 최적화에 대한 비용을 지불할 때는 항상 신중해야한다고 주장한다.
값을 비교하고 렌더링 또는 재계산이 필요한지 확인하는 작업, 이전에 결과물을 저장해 두었다가 다시 꺼내와야 한다는 두 가지 비용이 있다.

## 2.5.2 주장2 : 렌더링 과정의 비용은 비싸다. 모조리 메모이제이션해 버리자

컴포넌트가 렌더링이 자주 일어나며 그 렌더링 사이에 비싼 연산이 포함돼있고, 심지어 그 컴포넌트가 자식 컴포넌트 또한 많이 가지고 있다면 memo나 다른 메모이제이션 방법을 사용하는 것이 이점이 있을때가 분명 있다.

- memo를 컴포넌트의 사용에 따라 잘 살펴서 일부에만 적용하는 방법 : 이상적이지만 개발자들은 성능 향상에 쏟을 시간이 많지 않다!
- memo를 일단 그냥 다 적용하는 방법 : 잘못된 memo로 지불해야하는 비용은 바로 props에 대한 얕은 비교가 발생하면서 지불해야 하는 비용이다.

memo를 하지 않았을 때 발생할 수 있는 문제는 다음과 같다.

- 렌더링을 함으로써 발생하는 비용
- 컴포넌트 내부의 복잡한 로직의 재실행
- 위 두가지가 모든 자식 컴포넌트에서 반복해서 일어남
- 리액트가 구 트리와 신규 트리를 비교

대충봐도 memo를 하지 않았을때 잠재적 위험이 더 크다!

```jsx
function useMath(number: number) {
  const [double, setDouble] = useState(0);
  const [triple, setTriple] = useState(0);

  useEffect(() => {
    setDouble(number * 2);
    setTriple(number * 3);
  }, [number]);

  return { double, triple };
}

```
useMatch를 계속해서 호출하면, return 값의 참조가 변경된다.

```jsx
function useMath(number: number) {
  const [double, setDouble] = useState(0);
  const [triple, setTriple] = useState(0);

  useEffect(() => {
    setDouble(number * 2);
    setTriple(number * 3);
  }, [number]);

  return useMemo(()=> ({ double, triple }), [double, triple]);
}
```
useMemo로 감싸면 값이 변경되지 않으면 같은 결과물을 가질 수 있고, 사용하는 쪽에서도 참조의 투명성을 유지할 수 있게 된다. 즉, 메모이제이션은 컴포넌트 자신의 리렌더링뿐만 아니라 이를 사용하는 쪽에서도 변하지 않는 고정된 값을 사용할 수 있다는 믿음을 줄 수 있다.

