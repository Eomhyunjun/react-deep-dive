# 03장: 리액트 훅 깊게 살펴보기

## 3.1 리액트의 모든 훅 파헤치기

### 3.1.1 useState

> 함수 컴포넌트 내부에서 상태를 정의하고, 관리할 수 있게 해주는 훅

```jsx
const [state, setState] = useState;
```

- 사용할 state의 초기값을 넘겨줌.
- 아무런 값을 넘겨주지 않으면 초기값은 undefined
- 두번재 원소인 setState 함수를 사용해 해당 state의 값을 변경할 수 있음

**게으른 초기화**

- 일반적으로 useState에 원시값을 넣어주지만, 함수를 넘길 수도 있다.

```jsx
// 일반적인 useState 사용
// (함수를 실행하여 결과 값을 넣음)
const [count, setCount] = useState(
  Number.parseInt(localStorage.getItem("count"))
);

// 게으른 초기화
//(함수를 넣기)
const [count, setCount] = useState(() =>
  Number.parseInt(localStorage.getItem("count"))
);
```

함수를 실행한 값이 아닌 함수 그 자체를 넘겨주는 것을 의미

```jsx
import { useState } from "react";
import "./styles.css";

function instate() {
  console.log("hi");
  return 0;
}

export default function App() {
  const [s, ss] = useState(instate);

  return (
    <div className="App">
      <h1>{s}</h1>
      <button onClick={() => ss((prev) => prev + 1)}>vvv</button>
    </div>
  );
}
```

- 게으른 초기화는 useState의 초기값이 복잡하거나 무거운 연산을 포함하고 있을 때 사용하라고 되어 있음.
- state가 처음 만들어질 때만 사용됨. 리렌더링 발생 시 함수 실행 무시됨.

### 3.1.2 useEffect

> 애플리케이션 내 컴포넌트의 여러 값들을 활용해 동기적으로 부수 효과를 만드는 매커니즘

- 이 부수 효과가 **언제 일어나는지**보다 **어떤 상태값**과 함께 실행되는지 살펴보는 것이 중요함.
- 컴포넌트가 렌더링 된 후에 부수효과를 일으키고 싶을 때 사용하는 훅임.

**클린업 vs 클래스 컴포넌트의 언마운트**

- 언마운트: 특정 클래스에서 DOM이 사라진다는 것을 의미
- 클린업: 함수 컴포넌트가 리렌더링 됐을 때, 의존성 변화가 있을 경우 이전 상태를 청소해주는 개념

**의존성 배열**

- 아무런 값을 넘기지 않으면 → 렌더링마다 실행됨. (보통 컴포넌트 렌더링 확인하기 위한 방법)

  -> 그러면 안써도 되는 거 아님?

- 서버 사이드 렌더링 관점에서 useEffect는 클라이언트 사이드에서 실행되는 것을 보장해줌. (window 객체 써도 됨)
- useEffect는 컴포넌트 렌더링의 부수 효과이다.
  → 즉 컴포넌트 렌더링이 완료된 이후에 실행된다.
  → 반면 사용하지 않을 경우 컴포넌트 렌더링 도중에 실행된다.
  → 서버 사이드 렌더링의 경우에 서버에서도 실행됨. (컴포넌트 반환 지연 → 렌더링 방해함 → 성능 저해)

### 3.1.3 useMemo

> 비용이 큰 연산에 대한 결과를 저장(메모이제이션)해 두고, 저장된 값을 반환하는 훅

### 3.1.4 useCallback

> 인수로 넘겨받은 callback 자체를 기억하는 훅

사실 useMemo와 같음.

### 3.1.5 useRef

> useState와 동일하게 컴포넌트 내부에서 렌더링이 일어나도, 변경 가능한 상태값을 저장

### 3.1.6 useContext

> props drilling을 극복하기 위해 생긴 개념 / 명시적인 props 없이도 하위 컴포넌트에서 사용 가능

- 상태관리를 위한 리액트 API가 아님 → 상태를 주입해주는 API임

  - 상태 관리 라이브러리가 되기 위해서는
    1. 상태를 기반으로 다른 상태를 만들어낼 수 있어야 함.
    2. 필요에 따라 상태 변화를 최적화할 수 있어야 함.
       하지만 context는 둘 다 못함. 렌더링 최적화도 되지 않음.

  → 컴포넌트 트리 전체가 리렌더링

### 3.1.7 useReducer

> useState의 심화버전 → 좀 더 복잡한 상태값을 정의해 놓은 시나리오에 따라 관리 가능.

- 시나리오를 제한적으로 두고 이에 대한 변경을 빠르게 확인할 수 있게끔 하는 것이 목적
- useState → useReducer로 구현되어있음.
- 반대로 useReducer를 useState로 구현할 수도 있음.

### 3.1.8 useImperativeHandle

> 부모에게서 넘겨받은 ref를 마음대로 수정할 수 있는 훅. (current외에 추가적인 기능 추가 가능)

### 3.1.9 useLayoutEffect

> 함수의 시그니처는 useEffect와 동일하나, 모든 DOM의 변경 후에 **동기적**으로 발생한다.

- DOM의 변경 → 렌더링 (브라우저에 반영되는 시점 x)

  1. 리액트가 DOM 업데이트
  2. useLayoutEffect 실행 (브라우저 반영 전) → 실행 후 화면 그림
  3. 브라우저에 변경 사항 반영
  4. useEffect 실행

  → 동기적: 완료될 때까지 컴포넌트 중단 → 애플리케이션 성능 문제 발생

  → DOM은 계산됐지만, 화면에 반영되기 전에 하고 싶은 작업이 있을 때 사용

  - DOM 기반 애니메이션, 스크롤 위치 제어 등

### 3.1.10 useDebugValue

> 디거빙하고 싶은 정보 사용 시 리액트 개발자 도구에서 볼 수 있음.

- 훅 내부에서만 사용 가능
- 첫번째 인자가 바뀔 경우만 실행됨.

## 3.2 사용자 정의 훅과 고차 컴포넌트 중 무엇을 써야 할까?

리액트에서 재사용 로직을 관리하는 방법

1. 사용자 정의 훅
2. 고차 컴포넌트

### 3.2.3 사용자 정의 훅과 고차 컴포넌트 중 무엇을 써야 할까?

- 어떠한 로직을 공통화해 별도로 관리할 수 있다는 특징이 있음.
- 중복된 로직을 별도로 분리해 컴포넌트의 크기를 줄이고 가독성 향상에 도움을 줄 수 있음.

**사용자 정의 훅이 필요한 경우**

- 단순히 리액트에서 제공하는 훅으로만 공통로직을 격리할 수 있는 경우
  - 사용자 정의 훅 ⇒ 그 자체로는 렌더링에 영향을 미치지 못하기 때문에 사용이 제한적
  - 컴포넌트 내부에 미치는 영향을 최소화 → 개발자 훅을 원하는 방향으로만 사용할 수 있음

**고차 컴포넌트를 사용해야하는 경우**

- 사용자 정의 훅으로 표현하기 어려운 경우
  - 컴포넌트가 반환하는 렌더링 결과물에 영향을 미치는 경우
