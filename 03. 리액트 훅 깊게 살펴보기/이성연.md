# 03장: 리액트 훅 깊게 살펴보기

## 3.1 리액트의 모든 훅 파헤치기
### 3.1.1 useState
클로져로 구현!
#### 게으른 최적화(lazy initialization)
```jsx
const [count, setCount] = useState(Number.parseInt(window.localStorage.getItem(cacheKey)));

const [count, setCount] = useState(() => {
    Number.parseInt(window.localStorage.getItem(cacheKey));
})

```
게으른 초기화 함수는 오로지 state가 처음 만들어질 때만 사용된다. == 리렌더링시 이 함수의 실행을 무시



### 3.1.2 useEffect

`함수 컴포넌트는 매번 함수를 실행해 렌더링을 수행한다.`

`useEffect`는 state와 props의 변화 속에서 일어나는 렌더링 과정에서 실행되는 부수 효과 함수

클린업 함수는 생애주기 메서드의 언마운트와 조금 차이가 있다. 클린업 함수는 언마운트라기보다는 함수 컴포넌트가 리렌더링됐을 때 의존성 변화가 있었을 당시 이전의 값을 기준으로 실행되는, 말 그대로 이전 상태를 청소해주는 개념

`useEffect`는 클라이언트 사이드에서 실행되는 것을 보장 -> `useEffect`에서 window접근 가능

`useEffect`는 컴포넌트 렌러딩의 부수효과, 즉 컴포넌트 랜더링이 완료된 이후 실행.

`useEffect`는 컴포넌트가 랜더링 (브라우져 변화가 아닌 리액트 내부의 랜더링)된 후에 어떤한 부수 효과를 일으키고 싶을 때 사용하는 훅 (useLayoutEffect 참고)

빈배열 의존성, 즉 컴포넌트를 마운트하는 시점에서만 무엇인가 하고 싶다면 정말정말 필요한지 생각. `useEffect`는 의존성 배열로 전달된 값의 변경에 의해 실행되는걸 철학으로 하는 훅이다.

#### useEffect 함수 사용시 유의점
- 익명함수 대신 함수이름을 부여

```jsx
useEffect((
    function logActiveUser() {
        logging(user.id);
    },
    [user.id],
))
```

- 거대 useEffect ㄴㄴ
- 불필요한 외부 함수 ㄴㄴ

### 3.1.3 useMemo


### 3.1.4 useCallback
### 3.1.5 useRef
### 3.1.6 useContext
### 3.1.7 useReducer
### 3.1.8 useImperativeHandle
### 3.1.9 useLayoutEffect
### 3.1.10 useDebugValue
### 3.1.11 훅의 규칙
### 3.1.12 정리

## 3.2 사용자 정의 훅과 고차 컴포넌트 중 무엇을 써야 할까?
### 3.2.1 사용자 정의 훅
### 3.2.2 고차 컴포넌트
### 3.2.3 사용자 정의 훅과 고차 컴포넌트 중 무엇을 써야 할까?
### 3.2.4 정리