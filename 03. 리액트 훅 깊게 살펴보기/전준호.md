## ✨ 3.1  useState

---

- 클로져 개념을 사용해서, 이전 상태를 기억하고, 해당 상태를 기반으로 업데이트를 진행하고, 이를 반영한다
- Hook들은 index를 통해서 저장되어있고, 그렇기 때문에 조건문을 사용해서 hook의 순서가 변경되거나 하는 일이 일어나서는 안된다.
- Lazy Initialization ( 게으른 초기화 )
함수형 컴포넌트가 리렌더링이 일어날때 마다 State에 초기값을 계산해서 새로 넣어주는 작업을 할 경우 불 필요한 오버헤드가 발생한다. 이를 방지하기 위해서 State의 초기값에 함수를 넣어 줄 수 있는데 이럴 경우 최초의 렌더링에 1회만 실행되고 이후에는 실행되지않는다.

localStorage, sesseionStorage 에 접근하거나, map, filter, find와 같이 무거운 연산들이 초기값 계산에 필요할 경우 사용할 수 있다.

## ✨ 3.2  useEffect

---

### **useEffect의 동작**

- 콜백함수와, 의존성 배열을 인자로 받는다, 의존성 배열의 값이 변경되면 콜백함수가 실행된다.
- 클래스형 컴포넌트의 생명주기 메서드와 비슷한 동작을 구현할 수 있다.
( ComponentDidMount, componentDidUpdate, componentWillUnmount )
- 컴포넌트의 의존성 배열이 변경되거나, 컴포넌트가 unMount 될 때 클린업 함수가 실행된다.
- 의존성 배열이 빈배열이면 마운트시, 의존성 배열 자체를 주지않으면 렌더링마다 실행된다.

### useEffect의 특징

- useEffect의 콜백함수는 클라이언트 사이드에서 실행되는것을 보장해준다. 즉 window와 같은 객체에도 접근가능하다.
- 의존성 배열의 값을 비교는 [Object.is](http://Object.is) 와 마찬가지로 얕은 비교를 사용한다.

### 주의 사항

- 거대한 useEffect를 사용하지마라 
  useCallback, useMemo를 사용해서 내용을 정제하고, 잘게 나누자
- 불필요한 외부 함수를 만들지마라
  useEffect 내부에서만 실행되는 함수라면 즉시실행함수를 사용해서 해결할 수 있다.

❓ useEffect에서 콜백 인수로 비동기 함수?

- 경쟁상태(Race Condition) 가 생길 수 있다. 이전 useEffect로 실행된 함수가 현재의 결과를 덮어 쓸 수 있다.
- 함수 내부에는 비동기 함수를 실행할 수 있다. 마찬가지로 경쟁상태가 발생할 수 있으므로  클린업함수에 abortController, 클로져 개념을 사용해서 예방해준다.

❓ 컴포넌트의 값들을 이용해 동기적으로 부수 효과를 만든다? 부수 효과라는것이 뭘까요?

- 컴포넌트의 렌더링이 완료된 후에 실행하는것들이 모두 부수효과?

## ✨ 3.3, 3.4 useMemo, useCallBack

---

useMemo, useCallback 은 모두 최적화를 위해 사용되는 훅이다.

### useMemo

- 비용이 큰 연산에 대해서 결과값을 저장하고있는다.
- 컴포넌트에 대해서도 적용이 가능하지만, React.memo를 사용하는것을 추천한다.

❓ 왜 useMemo 대신 React.memo 를 사용하는것을 추천할까요?

- 해당 컴포넌트를 사용하는 모든 컴포넌트에서 memo를 선언하는거보다 컴포넌트 자체에 memo를 걸어놓는것이 실수를 방지하고 더 편해서?

### useCallback

- 값이 아닌 함수를 저장하고 있는다.
- JS에서 함수또한 값으로 저장될 수 있기 때문에 useMemo로 해도 상관없다, 반환문에 함수를 적어줘야하는 문제와, 값과 혼동이 올 수 있다는 점때문에 함수에 대해서는 useCallback을 사용한다.

## ✨ 3.5 useRef

---

useState와 마찬가지로 컴포넌트가 재렌더링이 일어나더라도, 변경 가능한 상태값을 저장하고 있는다.

Ref.current 를 통해서 해당값에 접근 가능하다. 일반적으로 DOM에 접근하고 싶을 때 사용한다.

**useState와 차이점** 

- current에 직접 접근해서 값을 변경할 수 있다.
- 값이 변하더라도 재 렌더링이 일어나지 않는다.

결론: 렌더링이 일어나지 않게 하면서, 원하는 값을 저장하고 싶을때 useRef 를 사용한다.

## ✨ 3.6 useContext

---

Props drilling을 피하기 위해서 사용하는 hook

❓ Props drilling ? 하위 컴포넌트에서 상위 컴포넌트의 데이터를 사용하기 위해서 해당 데이터를 사용하지 않는 상위 컴포넌트와 하위 컴포넌트 사이의 모든 컴포넌트에 해당 데이터를 props로 전달하는 일

**사용법**

- useContext를 사용하면 가장 가까운 상위 컴포넌트에서 만들어진 Provider의 값을 사용할 수  있다.
- 상위 컴포넌트에 Provider가 존재하지 않을경우 에러가 발생할 수 있으므로 이를 검사하는 hook으로 감싸서 이용하면 좋다.

**주의사항**

- 상위에 반드시 Provider가 존재하는 의존성을 갖게되고, 재사용하기 어려워 진다.
- 부모가 렌더링 되면 자식은 재렌더링이 일어나는 상황을 생각하고, memo를 사용해서 최적화를 해줘야한다.

## ✨ 3.7 useReducer

---

useState와 마찬가지로 상태를 관리하기 위해서 사용, 복잡한 형태의 state를 사전에 정의한 dispatcher를 통해조작한다. 코드내에서 state를 조작하는 로직과, 비지니스 로직을 분리할 수 있어서 관리에 용이해진다.

**사용법**

- reducer 함수, 초기값, lazy init 함수 3개의 인자를 받는다.
    - reducer : state와 action을 기반으로 state의 변화를 정의한다. 인자로 (State, action) 을 받고 State를 return 한다.
- const [state, dispatch] = useReducer(reducer, state, init) 과 같이 받았을때  dispatch 함수에 실행할 action을 넘긴다 
reducer 함수의 2번째 인자인 action 부분에 해당 객체가 들어가고, 정의한 동작에 따라서 동작하게된다.

## ✨ 3.11 Hook 의 규칙

---

- 최상위에서 훅을 호출해야 한다. 반복문이나 조건문, 중첩된 함수 내에서 훅을 실행할 수 없다. 컴포넌트가 렌더링 될 때 마다 항상 동일한 순서로 훅이 호출 되어야한다 → 파이버 내부에 순서에 따라서 이를 정리해놓기 때문
- 훅을 호출할 수 있는 것은 함수형 컴포넌트, 사용자 정의 훅 두가지 경우다. 일반 자바스크립트 함수에서 사용할 수 없다.
- 함수의 이름 앞에 use라는  키워드를 사용해서 사용자 정의 hook을 만들 수 있다. React에서 기본적으로 제공해주는 hook과 마찬가지로 React에서 hook으로 관리된다.

### 고차 함수

- 함수를 인수로 받거나 결과로 반환하는 함수
- Array.prototype.map과 같은 함수들을 칭한다. 이를 이용해서 커링 함수를 만들 수 있다.

```jsx
function add(a){
  return function (b) {
    return a + b
  }
}

const ret = add(a)(b)
```

### 고차 컴포넌트

- 관습적으로 앞에 with라는 키워드를 붙여서 해당 컴포넌트가 고차 컴포넌트라는 것을 알 수 있도록 표시해준다.
- 권한 여부에 따라 다른 페이지를 보여줄때 컴포넌트를 고차 컴포넌트로 감싸고, 그에 따라 다른 결과를 보여줄 수 있다.
