336 ~ 400

# 5장 : 리액트와 상태 관리 라이브러리

## 5.1 상태 관리는 왜 필요한가?

- 상태 => 어떠한 의미를 지닌 값, 앱 시나리오에 따라 지속적으로 변경될 수 있는 값.

### 5.1.1 리액트 상태 관리의 역사

#### Flux 패턴

- 단방향 데이터 흐름.
- 용어
  - action => 어떠한 작업을 처리할 액션과 액션 발생 시 함께 포함시킬 데이터. 액션 타입과 데이터를 정의해 디스패처로 보낸다.
  - dispatcher => 액션을 스토어에 보내는 역할. 콜백 함수 형태로 액션이 정의한 타입과 데이터를 스토어로 보낸다.
  - store => 실제 상태에 따른 값과 상태를 변경하는 매서드를 가진다. 액션의 타입에 따라 이를 변경할지 정의되어있다.
  - view => 리액트의 컴포넌트에 해당하는 부분. 스토에서 만들어진 데이터를 가져와 화면을 렌더링한다. 뷰에서도 사용자의 입력/행위에 따라서 상태를 업데이트하는 경우, 뷰에서 액션을 호출하는 구조로 구성된다.

#### 리덕스

- Flux 구조에 Elm 아키텍처 도입. (Elm => 웹 페이지를 선언적으로 작성하기 위한 언어)
- Elm 아키텍처 구조
  - model => 앱의 상태를 의미.
  - view => 모델을 표현하는 HTML을 의미.
  - update => 모델을 수정하는 방식을 의미.
- 리덕스는 하나의 상태 객체를 스토어에 저장해두고, 객체를 업데이트하는 작업을 디스패치해 업데이트를 수행.(reducer로 발생)
- props 드릴링 해결
- 단순한 작업에도 보일러플레이트가 너무 많다.

#### Context API 와 useContext

- props 드릴링 해결
- getChildContext (16.3 버전 이전)
  - 불필요한 렌더링 발생
  - context를 인수로 받아야해, 컴포넌트와 결합도가 높아짐
- Context API (16.3 버전)

#### 훅, React Query 그리고 SWR

- state 재사용 쉬워짐
- API 호출에 대한 상태 관리

#### Recoil, Zustand, Jotai, Valtio

- 훅을 사용해 작은 크기의 상태를 효율적으로 관리.

## 5.2 리액트 훅으로 시작하는 상태 관리

### 5.2.1 가장 기본적인 방법 : useState와 useReducer

- useState를 이용해서 커스텀 훅 구현 및 재사용이 가능해졌다.
  (351 action 잘 이해 안된다.)
- useReducer

  - 첫번째 인수 => reducer : state와 action을 어떻게 정의할지 넘겨줌.

- useState와 useReducer 기반 커스텀 훅의 한계
  - 훅 사용시 마다 컴포넌트별로 초기화 => 컴포넌트별로 상태의 파편화 발생.
  - useState 이용 시 local state의 경우 해당 컴포넌트 내에서만 유효
  - 전역 상태를 위해서는 상위 컴포넌트로 state를 끌어올린다.

### 5.2.2 지역 상태의 한계를 벗어나보자 : useState의 상태를 바깥으로 분리하기

- 함수 외부에서 상태를 참조하고 렌더링까지 연결하기 위한 조건

  1. 컴포넌트 외부에 상태를 두고 여러 컴포넌트가 같이 사용할 수 있어야한다.
  2. 외부에 있는 상태를 사용하는 컴포넌트는 상태 변화를 알아채고 리렌더링이 일어나 컴포넌트를 최신 상태 기준으로 렌더링 해야한다. 상태 변화 감지는 이 상태를 참조하는 모든 컴포넌트에 동일하게 동작해야한다.
  3. 상태가 원시값이 아닌 객체인 경우 그 객체에 내가 감시하지 않는 값이 변해도 리렌더링이 발생하지 않는다.

- 전역 상태 관리
  - store => 상태. 객체 혹은 원시값일 수도 있음.
  - callback => 값이 변경될 때마다 변경됐음을 알리는 함수.
  - subscribe => callback을 등록할 수 있는 함수

### 5.2.3 useState의 Context를 동시에 사용해 보기

### 5.2.4 상태 관리 라이브러리 Recoil, Jotai, Zustand 살펴보기
