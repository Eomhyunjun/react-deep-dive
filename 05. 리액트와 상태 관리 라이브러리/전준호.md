## ✨ 5.1 상태 관리는 왜 필요한가 ?

<aside>
💡

상태 ? → 어플리케이션의 시나리오에 따라 지속적으로 변경될 수 있는 값

</aside>

시나리오에 따라 상태가 변경되고 해당 상태를 반영해 적절한 동작과 화면이 구성될 수 있도록 만들어야한다.

상태를 잘못 관리할 경우 Tearing 현상이 일어날 수 있다. ( 상태관리가 적절하지 않아 의도하지 않은 동작을 하게 되는 경우 )

### ✅ Flux 패턴

기존의 MVC 패턴은 관리해야 할 상태가 많아질수록 관리하는데 어려움이 있었다.

HTML(view) → Js(Model) 을 변경하고 JS → HTML을 변경하게 되는 양방향 데이터바인딩을 사용하면서 시나리오가 복잡해질수록 관리가 어려워졌다.

이러한 문제를 해결하기 위해 단방향으로 데이터를 관리하는 Flux 패턴을 채택하기 시작했다.

Flux 패턴은 Action, Dispatcher, Store, View 4가지로 나뉜다.

- Action 
작업을 처리할 액션과, 함께 포함시킬 데이터를 의미한다. 액션 타입과 데이터를 정의하여 Dispatcher 에 보낸다.
- Dispatcher
 Action을 Store에 보내는 역할을 한다, 콜백 함수 형태로 액션이 정의한 타입과 데이터를 모두 Store에 보낸다.
- Store 
실제 상태에 따른 값과 상태를 변경할 수 있는 메서드를 가지고 있다, 액션의 타입에 따라 상태를 어떻게 변경할지 정의돼 있다.
- View
컴포넌트에 해당하는 부분, Store의 데이터를 기반으로 화면에 렌더링 한다. 또한 Action을 호출해 Dispatcher를 통해 상태를 update하는 요청을 보낼 수 있다.

### ✅ 사용자 정의 hook 과 한계

사용자 정의 hook을 사용해 상태관리에 필요한 로직들을 기존 컴포넌트에서 제거하고, 코드를 재사용 할 수 있다. 

하지만 지역 상태라는 특성의 한계 때문에, 공유를 위해서 부모 컴포넌트로 끌어 올려야할 필요가 생기고, 이를 위해 컴포넌트를 재설계 해야하는 상황이 발생할 수 있다.

이를 위해 리액트의 클로저가 아닌 사용자 정의의 클로저를 만들어서 관리하면 어떨까? → 리 렌더링을 트리거하기 위해서 고려해야 한다.

- window, global에 있을 필요는 없지만, 외부에 상태를 두고 여러 컴포넌트가 공유 할 수 있어야한다.
- 외부의 상태가 변환했을 때, 이를 바라보는 모든 컴포넌트가 감지하고, 리렌더링이 일어날 수 있어야한다.
- 객체의 변화로 인한 리 렌더링이 되서는 안된다?

위와 같은 사항을 고려해서 모든 컴포넌트들이 공통으로 하나의 상태를 바라 볼 수 있는 Store를 만들 수 있다.

### ✅ Store

Store 객체는 기본적으로 3개의 Property 를 갖는다

- get : 값을 받아 올 수 있는 함수.
- set: 값을 재정의 하는 함수.
- subscirbe : 개별 컴포넌트의 callback함수를 보관하여, store의 값이 변화했을 때 이를 실행해 해당 컴포넌트에 변경을 알린다.

❓ Subscribe 함수의 클린업 함수 ? 
컴포넌트에서 subscribe(callback)을 통해 store를 구독했을 때, 해당 반환값을 가지고 클린업 함수를 통해 지워줄 수 있도록 만들어준다. unSubscribe을 만들 필요없고, 또한 실수할 가능성을 줄여줄 수 있다.

- **useSyncExternalStore** 를 사용해서 React 외부의 Store를 사용할 수 있다.
- Context를 이용해 하위 컴포넌트에 주입하는 방식을 통해서 여러개의 스토어에 대해서 관리할 수 있다.
