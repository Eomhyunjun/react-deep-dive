# 05장: 리액트와 상태 관리 라이브러리

## 5.1 상태 관리는 왜 필요한가?

- 상태 : 의미를 지닌 값. 지속적으로 변경되는 값.
- 발전하는 웹 환경에서 복합적인 상태 관리를 효율적으로 관리하는 것에 대한 고민

### 5.1.1 리액트 상태 관리의 역사

프레임워크가 아닌 라이브러리인 리액트에서의 상태 관리는 많은 변화를 겪어옴.

- Flux 패턴
  - React 16버전에서 Context API, useContext를 선보이기 이전 유명한 상태 관리 라이브러리가 없었다.
  - 2014년, React 등장과 비슷한 시기의 Flux 패턴, Flux 라이브러리 등장.
    - 기존 웹 환경에서 MVC 패턴의 양방향 데이터 바인딩이 유지보수 어려움을 초래.
    - Flux의 단방향 데이터 흐름 제시
- 단방향 데이터 바인딩
  - action -> dispatcher -> store -> view / view -> dispatcher
  - action : 작업을 처리하는 action과 action이 사용하는 data
  - dispacther : 받은 action을 store에 전달하는 콜백함수
  - store : 실제 값을 변경하는 함수. switch 형태로 action의 타입에 따라 정의
  - view : React의 컴포넌트. store의 상태로 화면을 렌더링하는 동시, action을 호출할 수 있음
- React와 Flux 패턴의 시너지
  - 동일한 단방향 데이터 바인딩.
  - Flux 패턴을 준수하는 라이브러리의 등장.
- Redux
  - Flux 구조를 구현함과 동시에, Elm 아키텍처를 도입
    - Elm : 웹페이지를 선언적으로 작성하는 언어. model, view, update를 활용해서 동작.
  - 하나의 상태 객체가 변경될 때마다 웹 애플리케이션 전체에 전파.
    - props drilling 문제 해결.
  - 하나의 상태를 바꾸려고 해도 store, dispatcher, selector 등 보일러플레이트()가 많았다.
  - 오늘날 하나의 표준과 같은 위상을 차지.

### 5.1.2 정리

## 5.2 리액트 훅으로 시작하는 상태 관리

### 5.2.1 가장 기본적인 방법: useState와 useReducer

### 5.2.2 지역 상태의 한계를 벗어나보자: useState의 상태를 바깥으로 분리하기

### 5.2.3 useState와 Context를 동시에 사용해 보기

### 5.2.4 상태 관리 라이브러리 Recoil, Jotai, Zustand 살펴보기

### 5.2.5 정리
