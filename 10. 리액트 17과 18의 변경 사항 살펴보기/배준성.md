657 ~ 714

# 10. 리액트 17과 18의 변경 사항 살펴보기

## 10.1 리액트 17 버전 살펴보기

- 17 버전은 호환성 문제가 최소화 되도록 작업했다.

### 10.1.1 리액트의 점진적인 업그레이드

- 리액트 17 버전 부터는 일부 기능만 버전 업하는 것이 가능하다. 하지만 복잡성 감소 측면에서는 한꺼번에 업데이트하는 게 좋다.

### 10.1.2 이벤트 위임 방식의 변경

- 이벤트 위임: 이벤트 단계의 원리를 활용해 이벤트를 상위 컴포넌트에만 붙이는 것. 리액트는 이벤트 타입 당 하나의 핸들러를 루트에 부착한다.
- 이벤트의 단계
  1. 캡처: 이벤트 핸들러가 트리 최상단 요소에서 부터 시작해서 실제 이벤트가 발생한 타깃 요소까지 내려가는 것을 의미한다.
  2. 타깃: 이벤트 핸들러가 타깃 노드에 도달하는 단계. 이 단계에서 이벤트가 호출된다.
  3. 버블링: 이벤트가 발생한 요소에서 부터 시작해 최상위 요소까지 다시 올라간다.
- 리액트 17부터는 이벤트 위임이 모두 document가 아니라 리액트 컴포넌트 최상단 트리(루트 요소)로 바뀌었다. 이벤트 버블링으로 인한 혼선을 방지하기 위해서 개선되었다.

### 10.1.3 import React from 'react'가 더 이상 필요 없다: 새로운 JSX transform

- 바벨과의 협력을 통해 react를 import하지 않아도 JSX를 변환할 수 있게 되었다.
- React.createElement 에서 react/jsx-runtime으로 변경되었고, 내부 로직도 더 간결해졌다.

### 10.1.4 그 밖의 주요 변경 사항

- 이벤트 풀링 제거
- useEffect 클린업 함수의 비동기 실행
- 컴포넌트의 undefined 반환에 대한 일관적인 처리

## 10.2 리액트 18 버전 살펴보기

- 18 버전에서는 다양한 기능들이 추가됐다.
- 가장 큰 변경점은 동시성 지원이다.

### 10.2.1 새로 추가된 훅 살펴보기

- useId

  - 컴포넌트별로 유니크한 값을 생성하는 훅이다.
  - 서버 사이드 렌더링 환경에서 하이드레이션이 일어나는 경우에도 서버와 클라이언트가 동일한 값을 가져야하는데 useId를 사용하면 불일치를 피하면서도 고유한 값을 생성할 수 있다.
  - 생성된 값을 :로 감싸져 있다.

- useTransition

  - UI 변경을 가로막지 않고 상태를 업데이트 할 수 있는 훅이다. 상태 업데이트를 긴급하지 않은 것을 간주해 무거운 렌더링 작업을 조금 미룰 수 있다.
  - '동시성'을 다룰 수 있는 훅이다. 느린 렌더링 과정으로 인한 영향을 줄이고 사용자가 더 자연스럽게 서비스를 경험할 수 있게 한다.
  - 컴포넌트에서만 사용 가능한 훅이다.
  - 주의할 점
    - startTransition 내부는 반드시 setState와 같은 상태를 업데이트하는 함수와 관련된 작업만 넘길 수 있다.
    - startTransition으로 넘겨주는 상태 업데이트는 다른 모든 동기 상태 업데이트로 인해 실행이 지연될 수 있다.
    - startTransition으로 넘겨주는 함수는 반드시 동기 함수여야 한다.

- useDeferredValue

  - 리액트 컴포넌트 트리에서 리렌더링이 급하지 않은 부분을 지연할 수 있게 도와주는 훅이다.
  - 디바운스와 비슷하지만 몇 가지 장점이 있다.
    - 디바운스는 고정된 지연 시간이 필요하지만, useDeferredValue는 고정된 지연 시간 없이 첫 번째 렌더링이 완료된 이후에 useDeferredValue로 지연된 렌더링을 수행한다. 따라서 지연된 렌더링은 중단할 수 있으며, 사용자 인터렉션을 차단하지 않는다.

- useSyncExternalStore

  - 동시성 이슈 때문에 발생하는 테어링(tearing) 현상을 해결하기 위해서 추가된 훅이다. 리액트가 관리할 수 없는 외부 데이터 소스에 동시성 처리가 되어있지 않으면 테어링 현상이 발생할 수 있다.
  - useSyncExternalStore의 세가지 인수
    1. subscribe. 콜백 함수를 받아 스토어에 등록하는 용도로 사용된다. 스토어에 있는 값이 변경되면 이 콜백이 호출된다.
    2. 컴포넌트에 필요한 현재 스토어의 데이터를 반환하는 함수. 스토어에서 값이 변경됐다면 이 값을 이전 값과 Object.is로 비교해 정말로 값이 변경되었다면 컴포넌트를 리렌더링한다.
    3. (옵셔널). 서버 사이드 렌더링 시에 내부 리액트를 하이드레이션 하는 도중에만 사용된다. SSR에서 렌더링되는 훅이라면 반드시 이 값을 넘겨줘야 한다. 클라이언트 값과 불일치하면 오류 발생.

- useInsertionEffect
  - 서버 사이드에서 스타일 코드를 삽입하는 것을 돕는 훅.
  - useEffect와 기본적인 훅 구조가 동일하지만, 실행 시점이 다르다. DOM이 실제로 변경되기 전에 동기적으로 실행된다. (브라우저가 다시 스타일을 입혀서 DOM을 재계산하지 않아도 된다.)

### 10.2.2 react-dom/client

- 클라이언트에서 리액트 트리를 만들 때 사용되는 API가 변경되었다.

- createRoot

  - render 메서드를 대체하는 메서드. 리액트 18에서는 createRoot와 render를 함께 사용해야 한다.

- hydrateRoot
  - 서버 사이드 렌더링 app에서 하이드레이션을 저기하기 위한 메서드.
  - React DOM 서버 API와 함께 사용.

### 10.2.3 react-dom/server

- 서버에서 컴포넌트를 생성하는 API 또한 변경되었다.
- renderToPipeableStream
  - 리액트 컴포넌트를 HTML로 렌더링하는 메서드이다.
  - 스트림을 지원하는 메서드. HTML을 점진적으로 렌더링, 클라이언트에서 script를 중간에 삽입 가능.
  - 이를 통해서 suspense를 사용해 빠르게 렌더링이 필요한 부분을 먼저 렌더링 할 수 있고, 연산이 많은 부분은 이후에 렌더링 되게 할 수 있다.
- renderToReadableStream
  - renderToPipeableStream은 Node.js 환경에서의 렌더링을 위해 사용되며, renderToReadableStream은 웹 스트림을 기반으로 작동한다.

### 10.2.4 자동 배치(Automatic Batching)

- 자동 배치: 리액트가 여러 상태 업데이트를 하나의 렌더링으로 묶어서 성능을 향상시키는 방법.
- 자동 배치를 사용하고 싶지 않다면 flushSync를 사용하면 된다.(react-dom에서 제공)

### 10.2.5 더욱 엄격해진 엄격 모드

- 더 이상 안전하지 않은 특정 생명주기를 사용하는 컴포넌트에 대한 경고
  - componentWillooo 시리즈를 사용 시 경고 문구 발생.
- 문자열 ref 사용 금지
- findDOMNode에 대한 경고 출력
- 구 Context API 사용 시 발생하는 경고
- 예상치 못한 부작용 (side-effects) 검사
  - 검사를 위한 이중 호출 발생
    - 클래스 컴포넌트의 constructor, render, shouldComponentupdate, getDerivedstateFromprops
    - 클래스 컴포넌트의 setState 의 첫 번째 인수
    - 함수 컴포넌트의 body
    - useState, useMemo, useReducer에 전달되는 함수
  - 두번 실행되는 이유: 함수형 프로그래밍의 원칙에 따라 리액트의 모든 컴포넌트는 항상 순수하다고 가정하기 때문이다. 엄격 모드에서는 항상 순수한 결과물을 내고 있는지 개발자에게 확인시켜 주기 위해 두 번 실행하게 되는 것이다.

### 10.2.6 Suspense 기능 강화

- 컴포넌트를 동적으로 가져올 수 있게 도와주는 기능.
- React. Lazy를 통해 지연시켜 불러온 컴포넌트를 렌더링하는 역할을 한다.
- 두개의 인수를 받음
  1. fallback props: 지연시켜 불러온 컴포넌트를 미처 불러오지 못했을 때 보여주는 fallback.
  2. children: React.lazy 로 선언한 지연 컴포넌트.
- 렌더링 전에는 fallback을 보여주고, 지연 로딩이 완료되면 해당 컴포넌트를 보여준다.

### 10.2.7 인터넷 익스플로러 지원 중단에 따른 추가 폴리필 필요

### 10.2.8 그 밖에 알아두면 좋은 변경사항

- 컴포넌트에서 undefined를 반환해도 에러가 발생하지 않음. undefined 반환은 null 반환과 동일하게 처리.
- <Suspense fallback={undefined}>도 null과 동일하게 처리.
- renderToNodeStream 지원 중단, renderToPipeablestream 사용 권장
