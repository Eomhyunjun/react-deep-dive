# 10장: 리액트 17과 18의 변경 사항 살펴보기

- W3Techs 22년 8월 조사 기준 **55%** 가 **16**버전 사용, **11%** 가 **17**사용
  - 이때까지 18버전까지 나왔고, 최근 19버전 출시함
- 리액트 의존 라이브러리를 사용할 때는 peerDependencies를 확인해야 함.
- 17, 18버전에서 변화를 살펴보고자 함

## 10.1 리액트 17 버전 살펴보기

- 16 → 17 버전업은 큰 부담이 없음
  - 10만 개 이상의 컴포넌트 중 호환성이 깨지는 변경 사항에 영향을 받는 것은 20개 미만

### 10.1.1 리액트의 점진적인 업그레이드

- 리액트 유의적 버전을 사용
  - 개발자 편의를 위해 17부터는 점진적 업그레이드 가능해짐

### 10.1.2 이벤트 위임 방식의 변경

```jsx
<button onClick={~~}></button>
<button ref={buttonRef}></button>
```

- 버튼에 이벤트를 추가하는 방식

  1. onClick을 이용한 방식

     → 해당 버튼에는 noop이라는 함수가 달리고, 이벤트는 상위 컴포넌트에 위임됨

     → 이벤트 위임하는 이유는 돔 추가 삭제 시 이점을 가짐

     → 여기서 상위 컴포넌트는 16버전: document, 17버전: root요소 (최상단 트리)

     → root로 바뀐 이유는 점진적 업그레이드 지원과 다른 바닐라 코드나 jQuery 등의 라이브러리가 혼재돼 있는 경우 혼란을 방지하기 위함

     → 그럼 e.stopPropagation이 어떻게 적용되는거지?

  2. ref를 이용한 onclick 이벤트 추가 방식

     → 해당 버튼의 click 이벤트에 추가됨

### 10.1.3 import React from ‘react’가 더 이상 필요 없다: 새로운 JSX transform

- 기존 - `import React from ‘react’`가 필요했음. React를 사용하지 않아도 필요했음.
- 이제 react import 안해도 됨
- 필요 없는 `import React from ‘react’` 코드도 `react-codemod` 를 이용해 모두 삭제할 수 있음
  - **`npx react-codemod update-react-imports`**

### 10.1.4 그 밖의 주요 변경 사항

> **이벤트 풀링 제거**

이벤트 풀링: SyntheticEvent 풀을 만들어 이벤트가 발생할 때마다 가져오는 것.

**SyntheticEvent**

- 리액트에서 이벤트를 처리하기 위해 존재하는, 브라우저의 기본 이벤트를 한번 더 감싼 이벤트 객체
  - 리액트는 래핑한 이벤트를 사용하기 때문에, 이벤트가 발생할 때마다 이벤트를 새로 만들고 해제해야 함
  - 쏘 번거롭 + 메모리 낭비 + 메모리 누수의 위험 있음

[**이벤트 풀링 시스템**](https://blog.mathpresso.com/react-deep-dive-react-event-system-2-1d0ad028308b)

1. 이벤트 핸들러가 이벤트를 발생 시킨다
2. 합성 이벤트 풀에서 합성 이벤트 객체에 대한 참조를 가져온다.
3. 이 이벤트 정보를 합성 이벤트 객체에 넣어준다.
4. 유저가 지정한 이벤트 리스너가 실행된다.
5. 이벤트 객체가 초기화되고 다시 이벤트 풀로 돌아간다

- 언뜻 보기에는 이벤트 풀에 있는 합성 이벤트를 반복적으로 사용할 수 있어서 효과적으로 보이지만, 풀에서 이벤트를 받아오고, 이벤트가 종료되자마자 다시 초기화하는 방식은 사용하는 쪽에서 직관적이지 않았다.
- 이벤트를 재사용하는 과정에서 **SyntheticEvent**인 e에 접근하면 초기화 되어 에러가 났음.
  -> `e.persist()` 와 같은 처리가 필요했음

⇒ 직관적이지 않고, 성능 향상에 크게 도움이 안된다는 점 때문에 풀링 개념 삭제됨.

⇒ 모던 브라우저에서 이러한 이벤트 처리에 대한 성능이 많이 개선되어 의미가 더욱 퇴색됨.

**useEffect 클린업 함수의 비동기 실행**

- 원래 동기였으나, 화면이 완전히 업데이트 된 이후 비동기적으로 실행되도록 변경됨
- 커밋 후에 클린업 함수를 호출하므로 커밋 타임이 빨라짐.

**컴포넌트의 undefined 반환에 대한 일괄적인 처리**

리액트 16,17 버전

→ 컴포넌트 내부에서 undefined 반환하면 오류가 발생함

→ 이는 의도치 않은 반환으로 실수를 방지하기 위해서였음.

→ 하지만 리액트 16에서 forwarRef나 memo에서 undefined를 반환하는 경우에는 별다른 에러가 발생하지 않는 문제가 있었음

→ 17버전 부터는 에러가 정상적으로 발생함.

→ 18버전부터는 undefined 반환해도 에러 발생 안함

### 10.1.5 정리

모든 변경사항 보기 → https://legacy.reactjs.org/blog/2020/10/20/react-v17.html

## 10.2 리액트 18 버전 살펴보기

- 가장 큰 변경점 → [동시성](https://velog.io/@eunbinn/react-concurrency) 변경

### 10.2.1 새로 추가된 훅 살펴보기

- 새로운 훅 대거 추가

**userId**

- 컴포넌트별로 유니크한 값을 생성하는 훅
- 컴포넌트 내부에서 사용할 수 있는 유니크한 값을 생성하는 것 → 생각보다 쉽지 않음
  - 컴포넌트가 여러군데 재사용되는 경우도 고려해야하고
  - 컴포넌트 트리에서 컴포넌트가 가지는 모든 값이 다 달라야한다는 제약도 있음
  - 서버 사이드 렌더링 환경에서 하이드레이션이 일어날 때도 서버와 클라이언트에서 동일한 값을 가져야 에러가 발생하지 않으므로 이러한 것도 고려해야 함.
  ```jsx
  <div>{Math.random()}</div>
  ```
  - 위와 같은 컴포넌트가 서버 사이드에서 렌더링되어 클라이언트에 제공되는 경우
    → Math.random()값이 다르므로 에러가 발생함

**useTransition**

- UI 변경을 가로막지 않고 상태를 업데이트할 수 있는 훅
- 이를 활용하면 상태 업데이트를 긴급하지 않은 것으로 간주해 무거운 렌더링 작업을 조금 미룰 수 있으며, 사용자에게 조금 더 나은 경험을 제공할 수 있음.

```jsx
const [isPending, startTransition] = useTansition()

function selectTab(nextTab: Tab) {
	startTransition(() => {
		setTab(nextTab)
	})
}

return (
	<>
	{isPending ? '로딩 중' : <>내용<>}
	</>
```

- 훅을 사용할 수 없다면 startTransition를 직접 import할 수도 있음

**사용 예시**

- 탭 변경 시 → 무거운 작업이 있는 경우
- 작업 순서
  1. isPending이 true로 변경 됨
  2. 작업이 비동기로 진행됨
  3. 다른 작업이 있다면 해당 작업 멈추고, 새로운 작업 시작

**주의 사항**

- startTransition 내부에 반드시 setState와 같이 상태 업데이트 관련 작업만 넘길 수 있음. 만약 props나 사용자 정의 훅에서 반환하는 값 등을 사용하고 싶다면 뒤에서 설명할 useDefferedValue를 사용하면 됨
- startTransition으로 넘겨주는 상태 업데이트는 다른 모든 동기 상태 업데이트로 인해 실행이 지연될 수 있다. 예를 들어 타이핑으로 인해 setState가 일어나는 경우 타이핑이 끝날때까지 useTransition으로 지연시킨 상태 업데이트는 일어나지 않는다.
- startTransition으로 넘겨주는 함수는 반드시 동기 함수여야 한다. 만약 이 안에 setTimeout과 같은 비동기 함수를 넣으면 제대로 동작하지 않음. startTransition이 작업을 지연시키는 작업과 비동기로 함수가 실행되는 작업 사이에서 불일치가 일어나기 때문.

**useDefferedValue**

- 리렌더링이 급하지 않은 부분을 지연할 수 있게 도와주는 훅
- 디바운스(특정 시간 동안 발생하는 이벤트를 하나로 인식해 한 번만 실행하게 해주는)와 비슷, but useDefferedValue만의 차별점 몇가지 있음
  1. 고정된 지연 시간 없이 첫번째 렌더링이 완료된 이후에 지연된 렌더링 수행
  2. 중단 가능 + 사용자 인터렉션 차단하지도 않음

**useDefferedValue vs useTransition**

- useTransition은 state값을 업데이트하는 함수를 감싸서 사용
- useDefferedValue는 값 자체를 감싸서 사용
- 방식에서만 차이가 있고 동작은 같음, 상황에 맞춰서 쓰면 됨
- 만약 낮은 우선순위로 처리해야 할 작업에 대해 직접적으로 상태를 업데이트할 수 있는 코드에 접근할 수 있다면 useTransition을 쓰는 게 좋음.
- 컴포넌트의 props와 같이 상태 업데이트에 관려할 수는 없고 오로지 값만 받아야하는 상황이라면 useDefferedValue를 사용하는 게 타당함.

**useSyncExternalStore**

- useSubscription이 useSyncExternalStore으로 대체 됨

- 테어링(tearing) 현상
  - 렌더링을 일시 중지하거나 뒤로 미루는 등의 최적화가 가능해지면서 동시성 이슈가 발생할 수 있음.
  - 동일한 하나의 변수에 대해서 서로 다른 컴포넌트 형태가 나타날 수 있음.
  1. 첫번 째 컴포넌트에서는 외부 데이터 스토어의 값이 파란색이었으므로 파란색을 렌더링 했음
  2. 나머지 컴포넌트들도 파란색으로 렌더링 준비하고 있었음
  3. 갑자기 외부 데이터 스토어의 값 빨간색으로 바뀜
  4. 나머지 컴포넌트들은 렌더링 도중에 바뀐 색을 확인해 빨간색으로 렌더링
  5. 결론적으로 같은 데이터 소스를 바라보고 있음에도 컴포넌트의 색상이 달라지는 테어링 현상 발생
- 리액트에서 관리하는 state라면 내부적으로 문제 해결을 위한 처리를 해뒀지만, 리액트에서 관리할 수 없는 외부 데이터 소스에서라면 문제가 달라짐.
  - 리액트에서 관리할 수 없는 외부 데이터 소스
    리액트 클로저 범위 밖에 있는 값들 (글로벌 변수, document.body, window.innerWidth, DOM, 리액트 외부에 상태를 저장하는 외부 상태 라이브러리 등)
  - 리액트 외부 데이터 소스에서 동시성 처리가 되어있지 않다면 테어링 현상이 발생할 수 있음

⇒ 이 문제를 해결하기 위한 훅이 useSyncExternalStore

```jsx
useSyncExternalStore(
	subscript: (callback) => Unsubscribe
	getSnapshot: () => State
) => State
```

- subscript: 콜백 함수를 받아 스토어에 등록하는 용도. 스토어에 있는 값이 변경되면 이 콜백이 호출돼야 함. useSyncExternalStore가 이 훅을 사용하는 컴포넌트를 리렌더링함
- getSnapshot: 컴포넌트에 필요한 현재 스토어의 데이터 반환. 이 함수는 스토어가 변경되지 않았다면 매번 함수를 호출할 때마다 동일한 값 반환해야 함. 스토어에서 값이 변경됐다면 이 값을 이전 값과 Object.is로 비교해 정말로 값이 변경 됐다면 컴포넌트를 리렌더링함.
- 마지막 인수 옵셔널, 서버 사이드 렌더링 시에 내부 리액트를 하이드레이션하는 도중에만 사용됨. 서버 사이드에서 렌더링되는 훅이라면 반드시 이 값을 넘겨줘야 하며, 클라이언트의 값과 불일치가 발생할 경우 오류가 발생함.

**useInsertionEffect**

- CSS-in-js 라이브러리를 위한 훅

- useLayoutEffect는 모든 DOM의 변경 작업이 끝난 이후
- useInsertionEffect는 변경 작업 이전에 실행됨
- 브라우저가 다시금 스타일을 입혀서 DOM을 재계산하지 않아도 된다는 점에서 차이가 있음

### 10.2.2 react-dom/client

클라이언트에서 리액트 트리를 만들 때 사용되는 API

**createRoot**

- render 메서드를 대체하는 메서드
- 리액트 18의 기능을 사용하고 싶다면 createRoot와 render를 함께 사용해야 함.

**hydrateRoot**

- 서버 사이드 렌더링 애플리케이션에서 하이드레이션을 하기 위한 새로운 메서드
- react-dom/server api와 함께 사용됨

### 10.2.3 react-dom/server

**renderToPipeableStream**

- 리액트 컴포넌트를 HTML로 렌더링하는 메서드
- 스트림을 지원하는 메서드, HTML 점진적 렌더링, script 삽입 등의 작업을 할 수 있다.
- Suspense를 사용해 빠르게 렌더링에 필요한 부분을 먼저 렌더링할 수 있고, 값비싼 연산으로 구성된 부분은 이후에 렌더링되게끔 할 수 있음.
- hydrayteRoot를 호출하면 서버에서는 HTML을 렌더링하고, 클라이언트의 리액트에서는 여기에 이벤트만 추가함으로 첫번째 로딩을 매우 빠르게 수행할 수 있음.

**renderToReadableStream**

- renderToPipeableStream가 Node.js 환경에서의 렌더링을 위해서 사용된다면, renderToReadableStream는 웹 스트림을 기반으로 작동한다는 차이.

### 10.2.4 자동 배치(Automatic Batching)

- 여러 상태 업데이트를 하나의 리렌더링으로 묶어서 성능을 향상시키는 방법
- ex) 버튼 클릭 한 번에 두 개 이상의 state를 업데이트 하는 경우
  - 버전 상관없이 1번 리렌더링이 일어남.
  - 단 sleep과 같이 실행을 지연시키는 함수가 있다면 17에서는 2번, 18에서는 1번 리렌더링이 일어남
  - 과거 버전의 경우 이벤트 핸들러 내부에서는 자동 배치가 이뤄지고 있었지만, 비동기 이벤트에 대해서는 이뤄지지 않고 있었음
  - 리액트 18버전 부터 createRoot를 사용해서 만들면 모든 업데이트가 배치 작업으로 최적화 됨.
  - 혹시 이러한 작동 방식이 문제가 된다면, flushSync를 사용하면 된다(react가 아닌 react-dom에서 제공 됨)

### 10.2.5 더욱 엄격해진 엄격 모드

리액트 애플리케이션에서 발생할 수도 있는 잠재적인 버그를 찾는 데 도움이 되는 컴포넌트

**엄격 모드가 하는 일**

1. 더 이상 안전하지 않은 특정 생명주기를 사용하는 컴포넌트에 대한 경고
   - 클래스 컴포넌트에서 사용되는 생명주기 메서드 중 일부인 `componentWillMount`, `componentWillReceiveProps`, `componentWillUpdate` 사용에 대한 경고
2. 문자열 ref 사용 금지
   - `createRef` 없이 생성된 ref에 대한 경고
3. findDOMNode에 대한 경고 출력
   - 클래스형 컴포넌트 인스턴스에서 사용되던 `findDOMNode`에 대한 경고
4. 구 Context API 사용 시 발생하는 경고
   - `childContextTypes`와 `getChildContext`를 사용하는 구 리액트 Context API 사용에 대한 경고
5. 예상치 못한 부작용(side-effects) 검사

   다음 내용을 의도적으로 이중으로 호출한다.

   - 클래스형 컴포넌트의 constructor, render, shouldComponentUpdate, getDerivedStateFromProps
   - 클래스형 컴포넌트의 setState의 첫 번째 인수
   - 함수형 컴포넌트의 body
   - useState, useMemo, useReducer에 전달되는 함수

   각 컴포넌트가 항상 순수한 지 확인하기 위해서 두번씩 실행함.

**리액트 18에서 추가된 엄격 모드**

- 개발모드에서, 컴포넌트 마운트가 해제된 상태에서도 컴포넌트 내부의 상태값을 유지할 수 있는 기능

### 10.2.6 Suspense 기능 강화

- 기존의 Suspense

  - fallback을 먼저 띄워주고 lazy loading으로 불러온 컴포넌트가 렌더링 되면 그 후에 해당 컴포넌트를 보여줌
  - 초기 렌더링 속도를 높일 수 있었지만, 몇가지 문제점이 있었음
    1. 컴포넌트가 보이기도 전에 useEffect가 실행되는 문제
    2. 서버에서는 사용할 수 없었음

- 18버전의 Suspense
  - 컴포넌트가 보이기도 전에 useEffect가 실행되는 문제 해결(화면 노출 후 실행)
  - Suspense로 인해 컴포넌트가 보이거나 사라질 때도 effect가 정상적으로 실행됨
  - 서버에서 실행 가능
  - 자연스럽게 보이기 위한 스로틀링 추가

### 10.2.7 인터넷 익스플로러 지원 중단에 따른 추가 폴리필 필요

- Promise, Symbol, Object.assign 세 기능을 지원하지 않는 브라우저에서는 폴리필을 반드시 추가해야 함.

### 10.2.9 정리

- 리액트 18의 핵심 = 동시성 렌더링
