# 9.1 리액트 17 버전 살펴보기

- 리액트 애플리케이션의 버전 점유율: 0(12%), 15(21%), 16(55%), 17(12%)
- 가장 대표적인 애플리케이션 airbnb, netflix도 리액트 16 버전을 사용하고 있다(2022년 8월 기준).
- 16 버전만으로도 충분히 사용자에게 뛰어난 경험을 제공할 수 있지만, 최신 버전에서는 더 나은 기능을 가볍고 빠르게 제공해주는 장점이 있기 때문에 사용해볼 만하다.
- 또한 사용하는 라이브러리의 peerDependencies를 충족하기 위해서라도 최신 버전을 사용해야 할 수 있다.

- 리액트 17 버전은 16 버전과 다르게 새롭게 추가된 기능이 없다.
- 즉, 호환성이 깨지는 변경 사항을 최소화했다는 점이 가장 큰 특징이다.
- 16 버전 애플리케이션은 부담 없이 17 버전으로 업그레이드할 수 있다.

## 1. 리액트의 점진적인 업그레이드

- 유의적 버전 전략에 의하면, Major 버전이 올라갈 때는 호환성이 깨지는 변경 사항이 있다.
- 하지만 리액트 17 버전부터는 점진적인 업그레이드를 지원한다.
- 예를 들어, 리액트 18을 사용하면서도 일부 기능에 대해서는 리액트 17에 머물러 있는 것이 가능하다.
- 관리 포인트가 늘어나는 것이 단점이지만, 버전 변화에 유연하게 대응할 수 있다는 장점이 있다.
- 하나의 애플리케이션에서 하위 버전(e.g. 16)을 위한 별도의 루트 요소를 만들고, 불러온 하위 버전 리액트 모듈을 렌더링하는 구조로 함께 사용할 수 있다.
  - `lazyLegacyRoot`
- 결과적으로 버전 불일치로 인한 에러가 발생하지 않고, 하나의 웹 사이트에서 두 개의 리액트가 존재하는 것이 가능하다.
- Context가 제공하는 값도 마찬가지로 동일하게 사용할 수 있다.
- 이 접근 방식은 어디까지나 임시적인 방법이며, 버전 업그레이드를 위한 준비 단계로 사용하는 것이 좋다.

## 2. 이벤트 위임 방식의 변경

### 이벤트 핸들러를 처리하는 방식

- 아래 두 방식은 겉으로는 똑같이 해당 요소의 이벤트 리스너에 이벤트 핸들러를 등록하는 것처럼 보인다.
  - addEventListener: 해당 요소의 이벤트 리스너에 이벤트 핸들러를 등록한다.
  - 리액트: 위와 달리, 모든 이벤트 핸들러를 루트 요소의 이벤트 리스너에 부착하는데 이를 이벤트 위임이라고 한다.
- 이벤트 위임이란, 이벤트 단계의 원리(캡처링 -> 타겟 -> 버블링)를 이용해 이벤트를 상위 컴포넌트에만 붙이는 것을 의미한다.
- 리액트는 16 버전까지 각각의 이벤트 핸들러를 document 객체에 위임해서 이벤트를 조금 더 효율적으로 관리했다.
- 하지만 리액트 17 버전부터는 리액트 컴포넌트 최상단 트리(루트 요소)로 이벤트를 위임한다.
- 장점: 확장성 증가, 효율적인 관리 가능

### 리액트에서 이벤트 핸들러를 처리하는 과정

- 1. 브라우저에서는 해당 요소에 이벤트 리스너가 존재하지 않기 때문에, 특정 이벤트가 발생하면 이벤트 버블링을 통해 리액트가 **이벤트 위임**을 통해 루트 요소(#root) 또는 document에 부착한 이벤트 리스너를 찾는다 => 브라우저 네이티브 이벤트 위임
- 2. 리액트는 브라우저에서 발생한 네이티브 이벤트를 루트 요소(#root) 또는 document 에서 가로챈다.
- 3. 리액트는 네이티브 이벤트를 추상화된 SyntheticEvent로 변환하여 독자적인 합성 이벤트 전파 시스템에서 사용한다.
  - SyntheticEvent: 브라우저 간의 차이를 감추고 일관된 API를 제공, SyntheticEvent 객체를 재사용하여 메모리를 절약(풀링된 이벤트 시스템)
- 4. 리액트는 DOM 트리와 동일한 구조를 기준으로 합성 이벤트를 캡처링 → 타겟 → 버블링 순서로 전파한다.

- 네이티브 이벤트 전파 단계와 리액트 합성 이벤트 전파 단계는 독립적이다.
  - 리액트 16 버전에서는 document와 root 사이에서 `e.stopPropagation()`을 호출하면 네이티브 이벤트 전파 단계가 중단되므로 리액트의 모든 핸들러가 동작하지 않게 된다.
  - 리액트 17 버전에서는 루트 요소로 이벤트를 위임하므로, 리액트의 모든 핸들러의 동작이 보장된다.
- addEventListener 이벤트 핸들러에서의 이벤트 객체(PointerEvent)와 리액트 이벤트 핸들러에서의 이벤트 객체(SyntheticEvent)는 다르다.
- 리액트는 자체 이벤트 시스템을 가지고 있어서, 네이티브 DOM 이벤트를 직접 실행하지 않는다. 대신, 리액트는 이벤트 위임을 사용하여 최상위 요소에서 이벤트를 처리한다. 리액트의 이벤트 시스템은 document나 root 요소에 이벤트 리스너를 추가하고, 이벤트가 발생하면 이를 캡처하여 리액트의 이벤트 시스템(SyntheticEvent 및 Fiber tree)으로 전달한다.

- Q) 브라우저 네이티브 이벤트 캡처링/버블링 단계와 React 이벤트 캡처링/버블링 단계는 원래부터 구분되어 있었는가? A) React는 브라우저의 네이티브 이벤트를 루트 컨테이너(#root 또는 document)에서 가로챈 뒤, 자체적인 합성 이벤트 시스템을 사용해 별도로 캡처링/버블링 단계를 처리한다.
- Q) 브라우저 네이티브 이벤트는 document로 위임하는데만 쓰이고, 실질적으로 이벤트 버블링을 처리하는 것은 React 내부 구현인가? React는 브라우저 네이티브 이벤트를 단순히 루트 컨테이너에서 한 번만 감지하고, 이후 이벤트 버블링/캡처링 전파는 React 내부 시스템에서 구현한다. 네이티브 이벤트는 React의 합성 이벤트 시스템을 시작하는 트리거 역할만 할 뿐이다.

- 리액트 17 버전에서는 이벤트 위임 위치가 루트 요소로 변경하여, 리액트 컴포넌트 트리 수준으로 격리하였다. 덕분에 이벤트 전파가 독립적으로 동작하게 되어, 예측이 가능하고 안정적인 이벤트 핸들링이 가능해졌다.

### `stopPropagation()`

- 리액트 16 버전
  - 모든 이벤트가 최상위 DOM 요소(document)에 위임된다.
  - 네이티브 이벤트는 이미 document까지 전파되었기 때문에 document에 있는 네이티브 DOM 이벤트 핸들러(addEventListener)는 계속 실행된다.
  - SyntheticEvent.stopPropagation()은 리액트 내부의 이벤트 핸들러 전파만 중단시킨다.
- 리액트 17 버전
  - 모든 이벤트가 리액트 트리의 루트 노드로 위임된다.
  - SyntheticEvent.stopPropagation()는 React 트리 내에서의 전파가 중단시키고, 네이티브 DOM 이벤트도 루트 컨테이너를 넘어서 전파되지 않는다.
  - 즉, React 트리의 루트 컨테이너와 document 간의 이벤트 전파가 자연스럽게 동기화되며, 루트에서 전파를 중단하면 document에도 영향을 미친다고 할 수 있다.

```tsx
const { useState, useEffect } = React;

function ReactApp() {
  function App() {
    function onClick() {
      alert("form");
    }

    function onClick2() {
      alert("div");
    }

    function onClick3(e) {
      console.log(e); // SyntheticEvent, DOM에서는 PointerEvent로 서로 다르다.
      // 리액트 17
      // 아래 코드가 없으면, p -> div -> form -> document 순으로 이벤트가 전파된다.
      // 아래 코드가 있으면, p에서 이벤트가 중단된다.

      // 리액트 16
      // 아래 코드가 없으면, p -> div -> form -> document 순으로 이벤트가 전파된다. (같다)
      // 아래 코드가 있으면, p -> document 순으로 이벤트가 전파된다.
      e.stopPropagation();
      alert("p");
    }

    useEffect(() => {
      document.addEventListener("click", (e) => {
        alert("이벤트가 document까지 올라옴.");
      });
    }, []);

    return (
      <form onClick={onClick}>
        FORM
        <div onClick={onClick2}>
          DIV
          <p onClick={onClick3}>P</p>
        </div>
      </form>
    );
  }

  return ReactDOM.render(<App />, document.getElementById("root"));
}

ReactApp();
```

[SyntheticEvent 생성 및 이벤트 처리 과정](https://blog.mathpresso.com/react-deep-dive-react-event-system-1-759523d90341)

## 3. import React from 'react'가 더 이상 필요 없다: 새로운 JSX transform

- 이전 버전까지는 JSX를 사용하기 위해 `import React from 'react'`를 반드시 선언해야 했다.
- JSX가 변환될 때, React.createElement 함수를 호출하기 때문이다.
- 17 버전에서는 React.createElement가 아닌 react/jsx-runtime의 \_jsxRuntime을 사용하여 JSX를 변환한다.
- require()을 사용하므로 import React from 'react'를 선언하지 않아도 된다.
- 장점: jsx-runtime은 React.createElement보다 더 작고 빠르다. 불필요한 코드를 줄여줘서 번들 크기를 줄일 수 있다.

## 4. 이벤트 풀링 제거

- 리액트에서는 NativeEvent를 SyntheticEvent로 변환하여 이벤트를 처리한다.
- 이벤트를 만들 때마다 메모리 할당 작업이 일어나고, 메모리를 주기적으로 해제해야 하는 번거로움이 있었다.
- 이벤트 풀링: SyntheticEvent 객체 생성에 소요되는 시간을 줄이기 위해 SyntheticEvent Pool을 만들어서 이벤트가 발생할 때 가져올 수 있게 하였다.

- 과정

  1. 이벤트 핸들러가 이벤트를 발생시킨다.
  2. 합성 이벤트 풀에서 합성 이벤트 객체의 참조를 가져온다.
  3. 이벤트 정보를 합성 이벤트 객체에 넣어준다.
  4. 유저가 지정한 이벤트 리스너가 실행된다.
  5. 이벤트 객체가 초기화되고 다시 이벤트 풀로 돌아간다.

- 효과적인 방법처럼 보이지만, 풀에서 이벤트를 받아오고 이벤트가 종료되자마자 다시 null로 초기화하는 방식은 사용하는 쪽에서 직관적이지 않다.
- SyntheticEvent는 이벤트 핸들러 실행이 끝난 직후에 초기화된다. 이로 인해 비동기 코드 내부에서 SyntheticEvent 객체에 접근하려고 하면 이미 초기화된 상태이다.
- 비동기 코드 내부에서 이 합성 이벤트 e에 접근하기 위해서는 추가적인 작업인 e.persise()를 호출해야 했다. e.persist()를 호출하면 SyntheticEvent 객체가 이벤트 풀로 반환되지 않고, 초기화되지 않는다.
- SyntheticEvent를 풀링하여 얻는 성능 이점보다, 이를 관리하는 데 따른 복잡성이 더 큰 부담으로 작용했기 때문에 이벤트 풀링 기능을 제거하였다.

## 5. useEffect 클린업 함수의 비동기 실행

- 16 버전까지 useEffect의 클린업 함수는 동기적으로 실행되었기 때문에 불필요한 성능 저하가 발생할 수 있었다.
- 17 버전부터는 화면이 완전히 업데이트된 이후(커밋 단계가 완료된 이후)에 클린업 함수가 비동기적으로 실행되어 약간의 성능 향상을 가져왔다.
- Profiler 컴포넌트를 가지고 커밋 단계를 측정해보았을 때, 17 버전의 useEffect의 클린업 함수가 커밋 단계 이후에 실행되는 것을 확인할 수 있다.

## 6. 컴포넌트의 undefined 반환에 대한 일관적인 처리

- 리액트 16과 17 버전은 컴포넌트에서 undefined를 반환하면 오류가 발생한다. 의도치 않은 반환으로 인한 실수를 방지하기 위해서이다.
- 리액트 16 버전에서는 forwardRef나 memo에서 undefined를 반환하면 오류가 발생하지 않았다. 17 버전에서는 정상적으로 에러가 발생한ㄷ.
- 리액트 18 부터는 undefined를 반환해도 에러가 발생하지 않는다. 리액트 18부터는 컴포넌트가 undefined를 반환할 경우, null로 처리되어 렌더링 결과가 화면에 아무것도 표시되지 않도록 되었다.

## 정리

- 리액트 17 버전은 호환성을 깨지 않는 변경 사항을 최소화하고, 점진적인 업그레이드를 지원하는데 초점을 맞추었다.

# 10.2 리액트 18 버전 살펴보기

- 가장 큰 변화는 동시성 지원이다.

## 1. 새로 추가된 훅 살펴보기

### useId

- 컴포넌트별로 유니크한 값을 생성하는 새로운 훅
- 서버 사이드 렌더링 환경에서 _클라이언트와 서버에서 불일치를 피하면서_ 컴포넌트 내부의 고유한 값을 생성할 수 있다.
- CSS 선택자나 querySelector에서 작동하지 않도록 :로 감싸져있다.
- 유니크한 값은 현재 트리에서 자신의 위치를 나타내는 32글자의 이진 문자열이다. 앞글자가 R이면 서버에서 생성된 값, r이면 클라이언트에서 생성된 값이다.

### useTransition

- UI 변경을 가로막지 않고 상태를 업데이트할 수 있는 훅
- 느린 렌더링 과정에서 로딩 화면을 보여주거나, 지금 진행 중인 렌더링을 버리고 새로운 렌더링을 시작할 수 있다.
- 사용자에게 조금 더 자연스러운 서비스를 경험할 수 있게 해준다.
- startTransition을 바로 import 할 수도 있다.
- 목적: 상태 업데이트가 UI 반응성에 미치는 영향을 관리하는 것이다. 상태 업데이트(setState)와 관련이 없는 작업은 포함시키지 않아야 한다.
- startTransition으로 넘겨주는 상태 업데이트는 다른 모든 동기 상태 업데이트로 인해 실행이 지연될 수 있다. 예를 들어, 타이핑으로 인해 setState가 일어나는 경우, 타이핑이 끝날 때까지 useTransition으로 지연시킨 상태 업데이트는 일어나지 않는다. 즉, 타이핑이 계속 진행되는 동안에는 startTransition 내에서 지연시킨 상태 업데이트가 실행되지 않는다. React가 우선순위가 높은 동기 작업(예: 타이핑)을 처리한 뒤에 startTransition에 포함된 상태 업데이트를 처리하기 때문이다.

### useDeferredValue

- 리렌더링이 급하지 않은 부분을 지연할 수 있게 도와주는 훅
- 디바운스(특정 시간 동안 발생하는 이벤트를 하나로 인식하는 기법)과 유사하다.
- 디바운스는 고정된 지연 시간이 필요하지만, 이 훅은 첫 렌더링이 완료된 이후에 지연된 렌더링을 수행한다.
- 화면에 보여주는 값을 text가 아닌 deferredText로 설정함으로써 잦은 변경이 있는 text를 먼저 업데이트해 렌더링하고, 여유가 있을 때 지연된 deferredText를 활용해 렌더링한다.
- 작업이 오래걸려서 렌더링에 영향을 미칠수록, deferredValue로 처리하는 것이 좋다.
- text로 렌더링을 하면, input에 글자를 입력할 때마다 렌더링이 즉시 발생한다.
- 렌더링이 자주 발생한다면, 렌더링 성능에 영향을 미칠 수 있다.
- deferredText로 렌더링을 하면, 렌더링을 즉시 반영하지 않고 일정 시간이 지난 후에 업데이트되도록 하여 렌더링 빈도를 줄인다.
- 렌더링을 지연시켜 렌더링 성능을 최적화할 수 있다.

### useTransition과 useDeferredValue

- 공통점: 렌더링을 지연시킨다.

- useTransition
  - 상태 업데이트 함수(setState)를 지연시키는 것
  - e.g. 직접적으로 상태 업데이트 함수에 접근할 수 있는 경우
- useDeferredValue
  - 상태 값 렌더링을 지연시키는 것
  - e.g. 상태 업데이트에 관여할 수는 없고, 오로지 값만 받아야 하는 경우

### useSyncExternalStore

- 외부 스토어와 동기화하는 훅
- 리액트 17의 useSubscription 훅의 구현이 리액트 18에서 useSyncExternalStore로 대체되었다.
- 인자로 받은 콜백을 등록하고, 콜백이 호출될 때마다 (리)렌더링을 트리거하는 장치가 마련되어 있다.
- tearing: 리액트 18에서 동시성 개념이 등장하면서, 하나의 변수에 대해서 다른 컴포넌트에서 서로 다른 값으로 나타나는 현상.
- useTransition, useDeferredValue처럼 렌더링이 비동기적으로 처리되는 경우에 발생할 수 있다.
- useState, useReducer는 내부적으로 동시성 문제를 해결하였지만, 전역 상태 관리 라이브러리, window 객체, 외부 API와 같은 외부 스토어와의 동기화는 해결하지 못한다.

- 외부의 상태를 useState로 관리하면 tearing이 발생할 수 있다.
- 반대로 useSyncExternalStore로 관리하면, tearing이 발생하지 않는다.

- 라이브러리를 작성하는 것이 아니라면, 사용될 일이 없을 것이다.

### useInsertionEffect

- useSyncExternalStore이 상태 관리 라이브러리를 위한 훅이라면, useInsertionEffect는 CSS-in-js 라이브러리를 위한 훅이다.
- 잘 모르겠다..

- useEffect와 구조는 동일하지만 실행 시점이 다르다.
- useLayoutEffect처럼 조금 더 자연스러운 렌더링을 위해 사용된다.
- useInsertionEffect: DOM 변경 이전에 실행된다.
- useLayoutEffect: DOM 변경 후(커밋 단계, 브라우저 렌더링 이전)에 실행된다.
- useEffect: 렌더링이 완료된 이후에 실행된다.

- 라이브러리를 작성하는 것이 아니라면, 사용될 일이 없을 것이다.

## 2. react-dom/client

- 클라이언트에서 리액트 트리를 만들 때, 사용되는 API가 변경됐다.

### createRoot

- 기존의 react-dom의 render 함수를 대체한다.

```tsx
// before
ReactDOM.render(<App />, document.getElementById("root"));

// after
ReactDOM.createRoot(document.getElementById("root")).render(<App />);
```

### hydrateRoot

- 서버 사이드 렌더링에서 사용되는 hydrate 함수를 대체한다.
- 서버 사이드 렌더링 프레임워크를 사용한다면, 거의 사용할 일이 없다.

```tsx
// before
ReactDOM.hydrate(<App />, document.getElementById("root"));

// after
ReactDOM.hydrateRoot(document.getElementById("root"), <App />);
```

## 3. react-dom/server

### renderToPipeableStream

- 리액트 컴포넌트를 html로 렌더링하는 메서드이다.
- 스트림을 지원, html을 점진적으로 렌더링하고 클라이언트에서는 중간에 script를 삽입할 수 있다.
- 기존 renderToNodeStream의 문제는 무조건 렌더링을 순서대로 해야 하고, 순서에 의존적이라서 이전 렌더링이 끝나지 않는다면 다음 렌더링을 시작할 수 없다는 것이다.
- 특히, 초기 콘텐츠를 빠르게 제공하거나 비동기 데이터가 준비될 때까지 Suspense를 먼저 렌더링하는 데 유용하다.
- 서버가 첫 번째 HTML 조각을 스트리밍으로 즉시 보내므로, 사용자에게 더 빠르게 콘텐츠를 보여줄 수 있다.
- 이후 오래 걸리는 작업이 완료되면 나머지 콘텐츠를 스트리밍으로 보내 렌더링한다.

### renderToReadableStream

- renderToPipeableStream이 node.js 환경에서의 렌더링을 위해 사용된다면, renderToReadableStream은 웹 스트림을 기반으로 작동한다는 차이가 있다.
- Cloudflare나 Deno 같은 웹 스트림을 사용하는 모던 엣지 런타임 환경에서 사용되는 메서드이다.

## 4. Automatic batching

- 자동 배치는 리액트가 여러 상태 업데이트를 하나의 리렌더링으로 묶어서 성능을 향상시키는 방법을 의미한다.
- e.g. 버튼 클릭 한 번에 두 개 이상의 state를 동시에 업데이트할 때, 하나의 리렌더링으로 묶어서 수행한다.
- Profiler 컴포넌트를 이용해 확인하면, update(리렌더링)가 하나로 묶여있는 것을 확인할 수 있다.
- 또한 리액트 17 이하의 경우에도 자동 배치 작업이 이루어지고 있었지만, Promise, setTimeout, setInterval과 같은 비동기 작업이 있을 때는 자동 배치가 되지 않았다.
- 리액트 18에서는 createRoot를 이용해서 만들면 비동기 작업이 있어도 자동 배치가 이루어진다.
- 자동 배치를 적용하지 않으려면 flushSync를 사용하면 된다.

## 5. 더욱 엄격해진 엄격 모드

- 리액트 앱에서 발생할 수 있는 잠재적인 버그를 찾는데 도움이 되는 컴포넌트이다.
- 개발자 모드에서만 작동한다.

- 안전하지 않은 특정 생명주기를 사용하면 경고를 발생시킨다: UNSAFE\_로 시작하는 생명주기 메서드를 사용하면 경고를 출력한다.
- `문자열 ref` 사용을 금지한다: 과거에는 createRef 없이도 문자열로 ref를 생성하고 사용할 수 있었지만, 이제는 경고를 출력한다.
- `findDOMNode`에 대한 경고를 출력한다: 클래스 컴포넌트에서 실제 DOM 요소에 대한 참조를 가져올 수 있는 메서드이다.
- 구 Context API 사용시 경고를 출력한다: `childContextTypes`, `getChildContext`를 사용하면 경고를 출력한다.
- 예상치 못한 side effects를 검사할 수 있게 도와준다: 함수형 프로그래밍에서 리액트의 모든 컴포넌트는 항상 순수하다는 가정하에 동작한다. 항상 순수한 결과물을 내고 있는지 개발자에게 확인시켜주기 위함이다.

### 리액트 18에서의 엄격 모드

- 컴포넌트가 마운트 해제된 상태에서도 컴포넌트 내부의 상태값을 유지할 수 있는 기능을 제공할 예정이다.
- 뒤로가기를 했다가 다시 돌아왔을 때, 이전의 상태를 그대로 유지할 수 있게 한다.
- 컴포넌트가 최초 마운트될 때, 자동으로 모든 컴포넌트를 마운트 해제하고 두 번째 마운트에서 이전 상태를 복원하게 된다. 마치 useEffect가 두 번 작동한 것처럼 보인다.

## 6. Suspense 기능 강화

- 컴포넌트를 동적으로 가져올 수 있게 도와주는 기능이다.
- React.lazy: 컴포넌트를 첫 번째 렌더링 시에 불러오지 않고, 이후에 지연시켜 불러오는 역할을 한다.
- fallback props: 불러오는 중에 보여줄 컴포넌트
- children props: lazy로 불러올 컴포넌트

- 18 버전 이전에는 문제

  - 기존의 Suspense는 fallback이 끝나기 전에 자식 컴포넌트의 useEffect가 실행되는 문제가 있었다.
  - Suspense는 서버에서 사용할 수 없었다. 서버 사이드 렌더링 구조에서 Suspense를 사용하려면 useMount와 같은 훅을 구현해서 사용해야 했다.

- 위의 문제를 해결하였지만, 여전히 Suspense를 사용할 수 있는 시나리오는 제한적이다.(React.lazy, Next.js)

## 7. 인터넷 익스플로러 지원 중단에 따른 추가 폴리필 필요

- Promise, Symbol, Object.assign 을 지원하지 않는 브라우저에서 서비스해야 한다면 폴리필을 반드시 준비해야 한다.
- 리액트는 위의 기술을 사용할 수 있다는 가정 하에 배포된다.

## 8. 그 밖에 알아두면 좋은 변경사항

- undefined를 반환하지 않는 컴포넌트에도 에러를 발생하지 않는다.
- Suspense의 fallback에도 적용된다.
- renderToNodeStream의 지원이 중단되었다.

## 정리

- 18 버전은 많은 변화가 있었고, 핵심은 동시성 렌더링이다.
- 렌더링 중간에 일시 중지한 다음, 나중에 다시 시작하거나 렌더링을 포기할 수 있게 되었다.
- 이와 관련된 여러 훅(useTransition, useDeferredValue, useSyncExternalStore 등)도 추가되었다.
- 이러한 작업들은 메인 스레드를 차단하지 않고 백그라운드에서 수행되어 사용자의 반응성을 확보할 수 있게 되었다.
- 동시성 모드를 염두에 두고 있으면, 사용하고자 하는 라이브러리가 이를 완벽하게 지원하는지 검토해보자.
