# 10. 리액트 변경사항 살펴보기

## 10.1.1 점진적 업그레이드

두개의 루트를 이용해서 리액트의 두가지 버전을 하나의 사용하는 방식을 설명한다.

❓ 독립적인 Root를 가지고 행동한다. 프론트엔드 MSA 아키텍쳐도 이와 비슷한 방식으로 동작할까 ?

## 10.1.2 이벤트 위임 방식의 변경

기존에 Document에 모든 이벤트 핸들러를  달아주던 방식 → 루트 컴포넌트에 이벤트 핸들러를 달아주는 방식

- 기존에 여러 라이브러리를 섞어 사용하면서 발생하는 혼선을 방지해준다.

리액트의 이벤트 관리

- 리액트의 루트노드에서 모든 이벤트를 관리하기 때문에 이벤트 위임에 대해서 고려할 필요 없다 (자동으로 최적화를 진행해준다고 한다.)
- Synthetic 이벤트 객체를 이용해서 브라우저간의 호환성과 이벤트를 관리한다.
- 이벤트가 발생했을 때, 해당 이벤트 객체를 root로 보내서 이벤트를 처리하고, Fiber Tree에서 Target Node를 찾아 root Node 까지 이동하면서, Fiber가 해당 이벤트 Property를 갖고 있으면 큐에넣는다. Root Node에 도달하면 큐를 순차적으로 실행한다.
- 그렇기 때문에 DOM에 직접 이벤트를 부착했을때와, onClick과 같이 컴포넌트의 Props로 이벤트를 부착했을 때 차이점이 생길 수 있다.

이벤트 풀 

이전에는 이벤트객체를 재활용 하면서 신경써야 할 부분이 있었다. 16이하 버전을 사용하는것이 아니라면 중요하지 않을 것 같다.

useEffect 의 비동기 실행 

커밋단계가 끝난 후 비동기적으로 useEffect가 실행된다 → 화면이 그려진 후에 클린업 함수가 비동기적으로 실행된다 ? 만약에 비동기 동작을 하고 있었다면 문제가 되는 경우가 있을 수 있지 않을까?

## 10.2 리액트 18 버전 살펴보기

- useId : 현재 트리 위치를 기준으로 고유한 Id를 만들어 준다.

- useTransition  
무거운 렌더링 작업으로 인해 UI가 멈추는듯한 현상을 해결해 줄 수 있다.
setState와 같은 상태를 업데이트하는 함수와 관련된 작업만 할 수 있다, 반드시 동기 함수여야 한다.
props나 사용자 정의 훅에서 반환하는 값 등을 사용하고 싶으면 useDefferedValue를 사용한다.

❓ 어떤식으로 동작하는 것인지…
- useDefferedValue 
리렌더링이 급하지 않은 부분을 지연해서 렌더링 할 수 있게 해준다.
Transition 은 State의 업데이트를 지연시켜줬다면, DefferedValue는 props, state의 값으로 부터 파생되는 부분을 지연해서 렌더링 할 수 있게 도와준다.

책에 예제에서 보면 text는 즉각적으로 state가 변경되어 반영되지만 deferredValue 같은 경우에는 지연되서 적용된다.
이로인해서 text가 변경되더라도, deferredValue 같은 경우에는 변경되지 않아 Memo된 리스트를 그대로 이용하고, 불필요한 렌더링 작업에 많은 시간을 소비하지 않아도 된다.
이후에 deferredValue가 업데이트 되고, list를 다시 업데이트하고 렌더링 한다 ?
- useSyncExternalStore
리액트에 상태관리에서 벗어난 요소들로부터 리렌더링을 트리거하고 싶을 때 사용하는 훅.
zustand와 같은 라이브러리를 보면 해당 훅을 이용해서 작성하는 것을 확인할 수 있다.

첫번째 인자인 subscirbe 함수에 useSyncExternalStore 가 인자로 callback 함수를 넣어주는데, 해당 callback 함수를 실행하면 리렌더링이 트리거 된다. 이를 이용해서 외부값을 구독하고(ex. addEventListener,  callback )  리렌더링을 트리거 할 수 있다.

해당 훅을 사용하지 않아도 비슷한 구현이 가능하지만, 업데이트된 리액트 버전에서는 렌더링 도중에 중단되고 순서가 변하는 경우가 있기 때문에 tearing 현상이 일어날 수 있다. 이를 방지 하기 위해서 hook을 사용하는 편이 바람직하다.

- Suspense
내부에 Promise로 인해서 컴포넌트를 로딩할 수 없을 때 fallbackUI를 보여줄 수 있도록 한다 .
