# 11. Next.js 13과 리액트 18

Next 13은 가장 큰 변화가 생긴 릴리스다.

## 11.1 app 디렉터리

이전의 Next 12 버전까지는 페이지 공통 레이아웃을 유지할 수 있는 방법은 \_app이 유일했다. 이 방식은 제한적이고, 페이지별 서로 다른 레이아웃을 유지할 수 있는 여지도 부족하다. 이런 한계를 극복하기 위해 Next.js의 app 레이아웃이 나왔다.

### 11.1.1 라우팅

pages 라우팅 방식이 app 라우팅 방식으로 바뀌었다. 이전과 비슷하지만 약간의 차이가 있다.
13버전의 app 디렉터리 내부 파일명은 라우팅 명칭에 영향을 미치지 않는다. 가질 수 있는 파일명은 뒤에 설명할 예약어로 제한된다.

- layout.js

페이지의 기본적인 레이아웃을 구성하는 요소다. 해당 폴더에 layout이 있다면 하위 폴더 및 주소에 모두 영향을 미친다.
루트에는 단 하나의 layout을 만들어 둘 수 있다. 모든 페이지에 영향을 미치는 공통 레이아웃이며, `html`이나 `head`등 공통적인 내용을 다룬다.
꼭 공통 레이아웃이 필요하지 않아도 웹에 필요한 기본 정보만 담아도 충분히 유용하다.

- page.js: 일반적으로 다뤘던 페이지를 의미한다.
- error.js

해당 영역에서 사용되는 공통 에러 컴포넌트.
라우팅별로 서로 다른 에러 UI를 렌더링하는 것이 가능해진다.
`error: Error` 객체와 에러 바운더리를 초기화할 `reset: () ⇒ void`를 프롭스로 받는다.
다만 에러 바운더리는 클라이언트에서만 작동하므로, error 컴포넌트도 클라이언트 컴포넌트다.

- not-found.js: 라우팅 하위의 주소를 찾을 수 없는 404 페이지를 렌더링할 때 사용된다.
- loading.js: Suspense를 기반으로 컴포넌트가 불러올 때 사용된다.
- route.js

`/pages/api`와 동일하게 `/app/api`를 기준으로 디렉터리 라우팅을 지원한다.
이제 디렉터리가 라우팅 주소를 담당하며 파일명은 route.js로 통일되었다.

## 11.2 리액트 서버 컴포넌트

리액트 18에서 새로 도입된 RSC는 SSR과는 완전히 다르다.

### 11.2.1 기존 RSC와 SSR의 한계

지금까지의 SSR 구조는 서버에서 DOM을 만들어오고 클라이언트에서 이를 기준으로 하이드레이션을 진행한다. 지금까지의 구조는 몇 가지 명백한 한계가 있다.

- JS 번들 사이즈를 0으로 만들 수 없다.
- 백엔드 리소스에 대한 직접 접근 불가하다.
- 자동 code splitting이 불가하다. 코드 스플리팅은 하나의 큰 코드 번들 대신 여러 단위로 나누어 필요시에만 동적으로 지연 로딩하여 앱의 초기화 속도를 높여주는 기법이다. 일반적으로 리액트에서는 `lazy`를 사용한다.

  ```jsx
  import { lazy } from 'react';

  const Old = lazy(() => import('./OldPhotoRenderer.js'));
  const New = lazy(() => import('./NewPhotoRenderer.js'));

  function Photo(props) {
  		if (FeatureFlags.useNewPhotoRenderer)
  			return <newPhotoRenderer {...props} />
  		return <OldPhotoRenderer {...props} />
  	}
  }
  ```

  좋은 방법이지만 몇 가지 단점이 존재한다. 일일이 `lazy`로 감싸는 것을 기억해야 하며 해당 컴포넌트가 호출되고 if 문을 판단하기 전까지 어떤 지연 로딩 컴포넌트를 불러올 지 결정할 수 없다. 이는 지연 로딩의 성능 이점을 상쇄한다.
    <aside>
    
      ❓ 혹시 이 lazy 로딩 사용해본 분이 계신지?
    
    </aside>

- 연쇄적으로 발생하는 요청을 대응하기 어렵다.
- 추상화 비용이 증가한다.
  클라이언트에서 복잡한 작업을 하지 않게 되고, 서버에서는 최종 결과물만 간단히 보내주면 된다.

과거의 웹 어플 구축 방식인 PHP, 레일즈, JSP같은 SSG를 도입하면 이런 문제들을 해결할 수 있지만 리액트처럼 브라우저 상에서 다양한 경험을 제공하기 어렵다.

SSR과 CSR은 모두 이 문제를 해결하기는 아쉽다. SSR은 정적 컨텐츠를 빠르게 제공하고 서버 데이터를 쉽게 사용할 수 있는 반면 인터렉션에 따른 경험을 제공하기 어렵다. CSR은 인터렉션에 따라 다양한 경험을 제공하지만 서버에 비해 느리고 데이터 페칭도 어렵다. 이 두 강점을 모두 취한 것이 RSC다.

### 11.2.2 서버 컴포넌트란?

서버 컴포넌트란 하나의 언어, 프레임워크, API와 개념을 사용하여 서버와 클라이언트에서 컴포넌트를 렌더링 할 수 있는 기법을 의미한다. 서버에서 할 수 있는 서버에서 하고, 서버가 할 수 없는 작업은 브라우저에서 수행한다.
즉 일부는 서버에서, 일부는 클라이언트에서 렌더링 될 수 있다는 것이다. 클라이언트 컴포넌트는 서버 컴포넌트를 import 할 수 없다. 클라이언트 컴포넌트는 서버 컴포넌트를 실행할 수 없기 때문이다.
각 컴포넌트의 제약사항에 대해 알아보자.

![image.png](11%20Next%20js%2013%E1%84%80%E1%85%AA%20%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%2018%20161f383295a5809c8c3fd2d8ff4731c1/image.png)

- 서버 컴포넌트
  - 요청이 온 순간 서버에서 한 번 실행되므로 상태를 가질 수 없다. `useState`, `useReducer` 사용 불가.
    같은 이유로 렌더링 생명주기도 사용할 수 없다. `useEffect`, `useLayoutEffect`를 사용할 수 없다.
    즉, effect, state 의존 훅은 사용할 수 없다. 다만 서버에서 제공하는 기능만 사용하는 훅은 가능하다.
  - 브라우저에서 실행되지 않아 DOM API, `window`, `document` 객체 접근이 불가하다.
  - DB, 파일 시스템 등 서버 데이터를 `async/await`으로 접근 가능하다, 즉 컴포넌트가 async 할 수 있다.
- 클라이언트 컴포넌트
  - 브라우저 환경에서만 실행되므로 서버 컴포넌트를 불러오거나 서버 전용 훅, 유틸을 사용할 수 없다.
  - 서버 컴포넌트가 클라이언트 컴포넌트를 렌더링하는데, 그 클라이언트 컴포넌트가 자식으로 서버 컴포넌트를 갖는 구조가 가능하다.
    클라이언트 입장에서 서버 컴포넌트는 이미 서버에서 만들어진 트리를 가지며, 클라이언트 컴포넌트는 이미 서버에서 만들어진 그 트리를 삽입하여 보여주기만 하기 때문이다. 그렇기에 위 사진같이 서버 컴포넌트와 클라이언트 컴포넌트를 중첩해서 갖는 구조가 가능하다.
- 공용 컴포넌트(shared component): 서버와 클라이언트 모두에서 사용 가능하다. 그러므로 두 종류의 제약을 모두 받는다.

리액트는 모든 컴포넌트를 공용 컴포넌트로 판단한다. 즉 모든 컴포넌트가 서버 컴포넌트라고 분류하므로 클라이언트 컴포넌트라는 것을 명시적으로 선언하려면 `“use client”` 지시어를 파일 맨 첫 줄에 작성해두면 된다.

### 11.2.3 SSR과 RSC의 차이

앞서 살펴보았듯이 둘은 완전히 다른 개념으로 볼 수 있다.

SSR은 응답받은 페이지 전체를 HTML로 렌더링하는 과정을 서버에서 수행한 후 결과를 클라이언트에 내려준다. 이후 하이드레이션을 거쳐 서버 결과물을 확인하고 이벤트를 부착하는 작업을 수행한다.
목적: 인터렉션이 불가한 정적인 HTML을 내려주는 것에 초점을 둔다.
따라서 여전히 초기 HTML이 로딩된 후 클라이언트에서 JS 코드를 다운로드, 파싱, 실행하는 데 비용이 든다.

이를 RSC로 서버에서 렌더링 할 수 있는 컴포넌트는 서버에서 완성해 제공받고, 클라이언트 컴포넌트는 SSR로 초기 HTML을 빠르게 전달받을 수 있다.

## 11.3 Next.js에서의 리액트 서버 컴포넌트

### 11.3.1 새로운 fetch 도입과 getServerSideProps, getStaticProps, getInitialProps의 삭제

SSR과 SSG를 위해 사용되던 `getServerSideProps`, `getStaticProps`, `getInitialProps`가 앱 디렉토리에서 삭제되었다. 모든 데이터 요청은 `fetch`를 기반으로 이루어진다.

<aside>

    💡 To use an `async` Server Component with TypeScript, ensure you are using TypeScript `5.1.3` or higher and `@types/react` `18.2.8` or higher.
    If you are using an older version of TypeScript, you may see a `'Promise<Element>' is not a valid JSX element` type error. Updating to the latest version of TypeScript and `@types/react` should resolve this issue.

    이제 비동기 컴포넌트를 TS 5.1.3 버전 이상에서 지원해주는 것으로 보인다.

</aside>

![image.png](11%20Next%20js%2013%E1%84%80%E1%85%AA%20%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%2018%20161f383295a5809c8c3fd2d8ff4731c1/image%201.png)

추가적으로 fetch API를 확장해 같은 서버 컴포넌트 트리에서 동일 요청이 있으면 재요청이 발생하지 않게 요청 중복을 방지했다.
SWR과 리액트 쿼리와 비슷하게 해당 fetch에 대한 요청을 서버에서 렌더링이 한 번 끝날 때까지 캐싱하며, 클라이언트에서는 별도 지시자나 요청이 없는 이상 해당 데이터를 최대한 캐싱한다.

### 11.3.2 정적 렌더링과 동적 렌더링

getStaticProps로 서버 데이터가 변경되지 않으면 정적으로 페이지를 만들어 제공하는 기능이 있었지만, Next 13부터는 빌드 타임에 렌더링을 미리 해놓고 캐싱하고, 동적인 라우팅에 대해서는 요청이 올 때마다 컴포넌트를 렌더링하도록 변경했다.

### 11.3.3 캐시와 mutating, revalidating

fetch의 기본 동작을 재정의하여 캐싱을 통제한다. `revalidate`를 선언하면 해당 초마다 갱신하여 새로 렌더링한다. 캐시를 전체 무효화하고 싶다면 `router.refresh()`를 사용하면 된다. 이건 브라우저 새로고침과 상관이 없고, 오직 서버에서 루트부터 데이터를 전체적으로 가져와서 갱신하게 된다. state에 영향을 미치지 않는다.

### 11.3.4 스트리밍을 이용한 점진적 페이지 로딩

`Loading` 혹은 `Suspense`로 로딩이 끝나는 순서대로 컴포넌트 단위의 렌더링을 할 수 있게된다.

## 11.4 웹팩의 대항마, 터보팩의 등장(beta)

터보팩은 웹팩 대비 최대 700배, Vite 대비 최대 10배 빠르다고 한다. 러스트에 기반을 두고 있어 가능하다고 소개한다.

<aside>
    
    ❓팀원들은 어떤 번들러를 사용하는지? 그 이유는?

</aside>
