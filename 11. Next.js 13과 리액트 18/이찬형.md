# 11.1 app 디렉터리의 등장

### react-router-dom을 사용해 공통 헤더와 사이드 구현하기

- 모든 라우트 공통: <Routes> 컴포넌트 외부
- 특정 하위 주소: <Routes>의 element props에 전달하는 컴포넌트(이 컴포넌트는 <Outlet />을 포함해야 한다)

### Next.js 13 이전

- \_document는 페이지에서 쓰이는 <html>, <body>를 수정하는 등의 제한적인 용도로 사용된다.
- 페이지 공통 레이아웃을 유지할 수 있는 방법은 \_app이 유일했다. 제한적이기도 하고, 각 페이지별로 서로 다른 레이아웃을 유지할 수 있는 여지도 부족하다.

### Next.js 13 이후

- 이 한계를 극복하기 위해 나온 것이 app 디렉터리의 레이아웃이다.

## 라우팅

- /pages/a/b.tsx => /app/a/b/page.tsx
- 파일명으로 라우팅을 정의하지 못한다.

### layout.tsx

- 페이지의 기본적인 레이아웃을 구성하는 요소이다.
- 하위 폴더 및 주소(라우팅 영역)에 모두 영향을 미친다.
- URL의 query parameter(e.g. ?id=1)를 props로 받을 수 없다. 처리하려면 page.tsx를 사용해야 한다.
- 루트(/app)에 있다면, 모든 라우팅 영역에 영향을 미치는 것이라고 볼 수 있다.
- \_app, \_document를 하나로 대체할 수 있다: 모든 애플리케이션이 아니라 오로지 자신과 자식 라우팅에만 영향을 미치기 때문에 유연하게 구성이 가능하다.
- next가 제공하는 <Head>, <Body>등을 사용하지 않고, <head>, <body>를 직접 사용할 수 있다.
- children props를 사용해야 한다.
- API 요청과 같은 비동기 작업을 수행할 수 있다.

### page.tsx

- 페이지의 내용을 구성하는 요소이다.
- 이 파일이 존재하는 디렉터리에 따라 라우팅이 결정된다.
- props
  - params: 동적 라우트 매개변수(e.g. [id])를 사용하면, 해당 매개변수를 사용할 수 있다.
  - searchParams: URL의 query parameter(e.g. ?id=1)을 의미한다.

### error.tsx

- 해당 라우팅 영역에서 사용되는 공통 에러 컴포넌트이다. 특정 라우팅별로 서로 다른 에러 UI를 렌더링하는 것이 가능하다.
- 에러 바운더리는 클라이언트에서만 작동하므로 Error 컴포넌트도 클라이언트 컴포넌트여야 한다.
- 에러가 레이아웃 수준에서 발생하면, 해당 레이아웃의 error.tsx가 실행되지 않는다. 대신, 해당 레이아웃의 부모 레이아웃에 정의된 error.tsx로 이동하거나, 최상위 에러 핸들러가 처리한다.
- 레이아웃 자체가 무너지면 해당 레이아웃을 렌더링할 수 없기 때문에, 하위 경로의 에러 핸들링이 무의미해지기 때문이다. 따라서 레이아웃 에러는 상위 레이아웃이 처리하도록 설계되었다.

### not-found.tsx

- 특정 라우팅 하위의 주소를 찾을 수 없을 때 렌더링되는 컴포넌트이다.
- 전체 라우팅에서 사용하려면 /app/not-found.tsx를 작성한다.

### loading.tsx

- Suspense 컴포넌트를 사용할 때, 데이터를 불러오는 동안 렌더링되는 컴포넌트이다.
- "use client"를 사용헤 클라이언트에서 렌더링되게 할 수도 있다(?)

### route.ts

- Rest API의 GET과 같은 메서드명을 이용하여, HTTP 응답을 처리한다.
- 기존의 /pages/api 디렉터리와 비슷한 역할을 한다.
- 디렉터리와 메서드명으로 요청을 인지하고, 해당 메서드명에 해당하는 함수를 실행하여 응답을 반환한다.
- 디렉터리가 라우팅 주소를 담당하(반드시 app 디렉터리 내부에 없어도 된다)며, 파일명은 route.ts를 사용한다.
- page.tsx와 같은 디렉토리에는 존재하지 않아야 한다.

# 11.2 리액트 서버 컴포넌트

- 서버 컴포넌트는 서버 사이드 렌더링과는 완전히 다른 개념이다.
- 어떤 문제를 해결하기 위해서?

## 기존 리액트 컴포넌트와 서버 사이드 렌더링의 한계

- 컴포넌트: 클라이언트에서 작동하며, 브라우저에서 자바스크립트 코드를 실행한다.
- 클라이언트 사이드 렌더링: 리액트 실행에 필요한 코드를 다운로드 -> 리액트 컴포넌트 트리 생성 -> DOM 렌더링
- 서버 사이드 렌더링: 서버에서 DOM을 생성 -> 클라이언트에서는 DOM에 하이드레이션(상태, 이벤트 핸들러 추가)을 수행

### 지금까지의 구조의 명백한 한계점

- 자바스크립트 번들 크기가 0인 컴포넌트를 만들 수 없다
  - 원인: 클라이언트에서 라이브러리를 다운로드 및 실행해야 한다.
  - 해결: 서버에서 라이브러리를 실행한 결과와 컴포넌트 렌더링 결과물을 클라이언트에 전달하면 어떨까?
- 백엔드 리소스에 대한 직접적인 접근이 불가능하다
  - 원인: Rest API를 통해 백엔드에 접근해야 한다.
  - 해결: 클라이언트에서 직접 백엔드에 접근해 원하는 데이터를 가져오면 어떨까?
- 코드 분할이 불가능하다
  - 원인: 코드를 실행하기 전까지 어떤 lazy 컴포넌트를 렌더링할지 알 수 없어서 이점이 상쇄된다.
  - 해결: 서버에서 코드 분할을 자동으로 수행해준다면 어떨까?
- 연쇄적으로 발생하는 클라이언트와 서버의 요청을 대응하기 어렵다
  - 원인: 하나의 페이지에서 반복적으로 클라이언트와 서버 간의 요청과 응답이 발생하여 비효율적이다.
  - 해결: 클라이언트에서 연쇄적 요청없이, 서버에서 모두 수행하면 어떨까?
- 추상화에 드는 비용이 증가한다
  - 원인: 리액트 코드와 결과물(HTML) 사이에 추상화 계층이 추가되어 복잡성이 증가하고 런타임에 변환하는 비용이 발생한다.
  - 해결: 서버에서 리액트 코드를 실행하고, 결과물을 클라이언트에 전달하면 어떨까?
- 이렇게 서버 사이드 렌더링의 한계점을 쭉 살펴본다면 모든 문제는 리액트가 클라이언트 중심으로 돌아가기 때문에 발생하는 문제라는 것을 알 수 있다.
- 결국 SSR, CSR 모두 이 문제를 해결하기에는 조금씩 아쉬움이 있다.
- 두 구조의 장점을 모두 취하고자 하는 것이 바로 리액트 서버 컴포넌트이다.

## 서버 컴포넌트란?

- 서버와 클라이언트 모두에서 컴포넌트를 렌더링할 수 있는 기법을 의미한다.
- 즉, 일부 컴포넌트는 클라이언트에서 일부 컴포넌트는 서버에서 렌더링하는 방법이다.
- GPT) 리액트 서버 컴포넌트는 클라이언트에서 실행될 필요가 없는 일부 컴포넌트를 서버에서 실행할 수 있도록 지원한다.
- 서버 컴포넌트는 서버에서 실행되고, 그 결과로 생성된 HTML과 데이터를 클라이언트에 전달한다. 클라이언트는 이 결과를 바로 렌더링하며, 추가 자바스크립트를 다운로드하지 않는다.

- 클라이언트 컴포넌트는 서버 컴포넌트를 import 할 수 없다. 만약 클라이언트 컴포넌트가 서버 컴포넌트를 불러오게 된다면 브라우저에서는 서버 환경이 존재하지 않으므로 서버 컴포넌트를 실행할 수 없다.

- 서버 컴포넌트
  - 상태를 가질 수 없다: useState, useReducer, 사용자 정의 훅을 사용할 수 없다.
  - 생명주기가 없다: useEffect, useLayoutEffect를 사용할 수 없다.
  - window, document와 같은 클라이언트 전역 객체에 접근할 수 없다.
  - 비동기 함수 컴포넌트로 만들 수 있다.
  - 서버 컴포넌트, 클라이언트 컴포넌트 둘 다 렌더링이 가능하다.
- 클라이언트 컴포넌트
  - 리액트 컴포넌트와 대부분 같다: 상태, 생명주기, 전역 객체에 접근 가능하다.

```tsx
// 서버 컴포넌트를 불러올 수 없다.
import { ServerComponent } from "./ServerComponent";

export default function ClientComponent() {
  return (
    <div>
      <ServerComponent />
    </div>
  );
}
```

```tsx
// 서버 컴포넌트가 클라이언트 컴포넌트를 렌더링하는데, 그 클라이언트 컴포넌트가 자식으로 서버 컴포넌트를 갖는 구조는 가능하다
// 클라이언트 컴포넌트는 서버에서 생성된 트리를 받아서 렌더링할 수 있기 때문이다.
export default function ClientComponent({ children }) {
  return <div>{children}</div>;
}

export default function App() {
  return (
    <ClientComponent>
      <ServerComponent />
    </ClientComponent>
  );
}
```

- 공용 컴포넌트
  - 서버, 클라이언트에서 모두 사용할 수 있다. 둘 다의 제약을 받는 컴포넌트가 된다.
- 리액트는 모든 것을 다 공용 컴포넌트로 판단한다. 즉, 모두 서버에서 실행 가능한 컴포넌트로 분류한다.
- 리액트 서버 컴포넌트는 여러 가지 제약 요소로 인해 번들러나 특정 프레임워크의 도움을 받는 것이 필수적이다. 서버 컴포넌트를 구현하기 위해서 웹팩. Next.js 등과 함께 협업하였다.

### 서버 사이드 렌더링과 서버 컴포넌트의 차이

- 서버 사이드 렌더링: 서버에서 페이지 전체를 HTML로 렌더링하고 응답으로 클라이언트에게 보내준다. 이후 클라이언트에서 하이드레이션을 거친다.
  - 목적: 초기에 인터랙션은 불가능하지만, HTML을 빠르게 내려주는데 초점이 있다.
  - 여전히 클라이언트에서 자바스크립트 코드를 다운로드, 파싱, 실행하는데 시간이 소요된다.
- 서버 사이드 렌더링과 서버 컴포넌트 동시 채택
  - 서버 컴포넌트를 활용해 서버에서 렌더링할 수 있는 컴포넌트는 서버에서 완성해서 제공받은 다음, 클라이언트 컴포넌트는 서버 사이드 렌더링으로 초기 HTML을 전달받는다.
  - 클라이언트 컴포넌트와 서버 컴포넌트 모두 빠르게 보여줄 수 있고, 자바스크립트 다운로드의 양도 줄어들 것이다.

### 서버 컴포넌트는 어떻게 작동하는가?

1. 서버가 렌더링 요청을 받는다. 루트에 있는 컴포넌트는 항상 서버 컴포넌트이다. 루트부터 서버 렌더링을 시작한다.
2. 서버는 컴포넌트를 JSON(와이어 포맷)으로 직렬화한다. 서버에서 렌더링할 수 있는 것은 직렬화하여 내보내고, 클라이언트 컴포넌트는 공간을 비워둔다.
3. 브라우저에 JSON을 스트리밍을 통해 전송한다: 사용자는 결과물을 빠르게 볼 수 있다.
4. 브라우저는 JSON을 받아 역직렬화를 수행한다.
5. 브라우저는 클라이언트 컴포넌트는 렌더링하고, 서버 컴포넌트는 그대로 가져와서 컴포넌트 트리를 구성한다.

- 서버 사이드 렌더링처럼 결과가 HTML이 아니라 JSON이다. 이 구조는 리액트 컴포넌트 트리의 구성을 최대한 빠르게 할 수 있도록 도와준다.
- JSON으로 직렬화할 수 없는 데이터(e.g. class, Date)는 서버에서 클라이언트로 넘겨줄 방법이 없다(자바스크립트 고유 객체이기 때문이다).

# 11.3 Next.js에서의 리액트 서버 컴포넌트

- 기본적인 서버 컴포넌트는 리액트 서버 컴포넌트와 동일하다.
  - 클라이언트 컴포넌트는 서버 컴포넌트를 불러올 수는 없고, children props로 받아서 렌더링만 가능하다.
- page.tsx는 루트 컴포넌트가 되어 서버 컴포넌트이다.
- layout.tsx는 반드시 서버 컴포넌트이다.

## 새로운 fetch 도입과 getServerSideProps, getStaticProps, getInitialProps의 삭제

- app router에서는 위와 같은 메서드가 삭제되고 fetch 기반으로 변경되었다.
- 페이지 컴포넌트에서 fetch를 통해 직접 데이터를 불러올 수 있고, async 키워드도 사용할 수 있다.
- 리액트 팀(?)은 fetch API를 확장하여 요청 중복을 방지했다.
- 서버에서는 fetch 요청을 렌더링이 한 번 끝날 때까지 캐싱(동일한 fetch 요청이 한 번만 발생하고 캐싱된 데이터를 재사용)하며, 별도의 요청이 없는 이상 해당 데이터를 최대한 캐싱해서 중복된 요청을 방지한다.

## 정적 렌더링과 동적 렌더링

- Next.js 13
- 정적인 라우팅에 대해서는 기본적으로 빌드 타임에 렌더링을 해두고 캐싱해 재사용할 수 있게 되었다.
  - 내부에서 비동기 요청을 하더라도 빌드 타임에 렌더링을 해두고 캐싱해두기 때문에, 빌드 타임에 렌더링된 결과물을 재사용한다.
  - 캐싱을 비활성화하려면, `fetch(url, { cache: 'no-cache' })` 또는 `fetch(url, { next: { revalidate: 0 } })`으로 fetch를 호출한다.
  - next/cookie, next/header 패키지를 사용한다면, 정적 렌더링에서 제외된다.
- 동적인 라우팅에 대해서는 매번 요청이 올 때마다 컴포넌트를 렌더링하도록 변경했다.
  - 동적 라우팅인데 캐싱이 필요할 경우(getStaticPaths)에는, 새로운 메서드인 generateStaticParams를 사용한다.

## 캐시와 mutating, 그리고 revalidating

- Next.js는 fetch의 기본 동작을 재정의해 캐싱을 적용했다.
- 위에서 revalidate를 이용해 캐시 유효 시간을 설정했었는데, 변수로 설정하는 방법도 존재한다. 하위 라우팅 영역에 모두 영향을 미친다.

```tsx
// app/page.tsx
export const revalidate = 60;
```

- 동작 방식

  1. 최초로 라우트로 요청이 올 때는 미리 정적으로 캐시해 둔 데이터를 보여준다.
  2. 이 캐시된 초기 요청은 revalidate에 선언된 값만큼 유지된다.
  3. 만약 해당 시간이 지나도 일단은 캐시된 데이터를 보여준다.
  4. 내부적으로는 백그라운드에서 캐시를 업데이트한다.
  5. 4번의 작업이 성공하면 갱신하고, 아니라면 과거 데이터로 유지한다.

- 캐시를 전체적으로 무효화하고 싶다면, `router.refresh()`를 사용한다: 브라우저의 히스토리에 영향을 미치지 않고 갱신한다. 브라우저나 리액트의 state에는 영향을 미치지 않는다.

## 스트리밍을 활용한 점진적인 페이지 불러오기

- 과거에는 하이드레이션이 끝나야만 페이지 하나를 온전하게 볼 수 있다.
- 페이지가 완성될 때까지 기다리는 것이 아니라 HTML을 작은 단위로 쪼개서 클라이언트에 점진적으로 보내는 스트리밍이 도입되었다.
- 장점
  - 사용자가 일부라도 페이지와 인터랙션을 할 수 있다.
  - Time to First Byte(TTFB)를 줄일 수 있고, First Contentful Paint(FCP)를 빠르게 할 수 있다.
  - 사용자는 기다림과 지루함을 덜 수 있다.
  - 페이지가 로딩 중이라는 인식을 더 명확하게 심어줄 수 있다.
- loading.tsx 컴포넌트를 사용하거나 <Suspense /> 컴포넌트를 직접 사용할 수 있다.

# 11.4 웹팩의 대항마, 터보팩의 등장(beta)

- 웹팩의 후계자를 자처하고 있는 터보팩은 웹팩 대비 최대 700배, Vite 대비 최대 10배 빠르다고 한다.
- 러스트 언어로 작성되었다.
- 아직 개발 모드에서만 제한적으로 사용할 수 있다.

# 11.5 서버 액션(alpha)

- Next.js 13.4.0 버전에서 서버 액션이 추가되었다.
- API를 굳이 생성하지 않더라도 함수 수준에서 서버에 직접 접근하여 데이터 요청 등을 수행할 수 있는 기능이다.
- 서버 컴포넌트와 다르게, 특정 함수 실행 그 자체만을 서버에서 수행할 수 있다는 장점이 있다.
- 서버 액션을 만드려면 `use server`를 명시해야 하고, async 함수여야 한다.

## form의 action

- <form> 태그의 action props를 추가해서 서버로 데이터를 전송할 수 있다.
- 이벤트를 발생시키는 것은 클라이언트지만, 실제로 함수가 수행되는 것은 서버가 된다.
- 서버 액션을 실행하면 클라이언트에서는 ACTION_ID만 보내고, 서버에서는 해당 ID에 해당하는 함수를 실행한다.
- **빌드 시점에 미리 클라이언트에서 액션을 분리시키고 서버로 옮김으로써 클라이언트 번들링 결과물에는 포함되지 않게 된다.**

- form과 렌더링되는 데이터가 연동돼 있을 때 더욱 효과적이다.
  - 먼저, `const data = await kv.get<Data>(key)`와 같은 형태로 직접 서버 요청을 수행해서 컴포넌트를 렌더링한다.
  - 이후, handleSubmit 함수를 통해 formData를 가져와 데이터베이스인 kv를 업데이트한다.
  - 그리고 revalidatePath(server mutation)를 통해 캐시를 갱신하고 컴포넌트를 리렌더링한다.
- php와의 차이는 모든 과정이 페이지 새로고침 없이 데이터 스트리밍으로 이루어진다는 것이다.

- server mutation: 인자로 넘겨받은 경로의 캐시를 초기화해서 경로에서 즉시 새로운 데이터를 가져오는 역할을 한다.
  - redirect
  - revalidatePath
  - revalidateTag

## input의 submit과 image의 formAction

- <input type="submit">, <input type="image"> 에 formAction을 추가하여 서버 액션을 사용할 수 있다.

## startTransition과의 연동

- useTransition의 startTransition에서도 서버 액션을 활용할 수 있다.
- startTransition 내부에 서버 액션 함수를 실행하는 방법으로 사용한다.
- loading.tsx를 사용하지 않고 isPending를 사용해 로딩 상태를 표시할 수 있다는 장점도 있다.

## server mutation이 없는 작업

- server mutation이 필요하다면, 반드시 useTransition과 함께 사용해야 한다.
- 하지만 server mutation이 필요하지 않다면, 서버 액션 함수를 바로 이벤트 핸들러처럼 사용해도 된다.

## 서버 액션 사용 시 주의할 점

- 서버 액션은 클라이언트 컴포넌트 내에서 정의될 수 없다.

# 11.6 그 밖의 변화

- 13.0 -> 13.4
- 프로젝트 전체 라우트에서 쓸 수 있는 미들웨어가 강화되었다.
- SEO를 쉽게 작성할 수 있는 기능이 추가되었다.

  - 중앙화된 SEO 관리: metadata 객체에서 모든 메타 데이터를 정의
  - OpenGraph 지원: 소셜 미디어에서 공유될 때의 메타 데이터를 쉽게 정의 가능
  - 페이지 기반 SEO: 각 페이지에서 별도로 SEO 데이터를 선언

```tsx
export const metadata = {
  title: "My Awesome Page",
  description: "This is an example of Next.js SEO metadata.",
  openGraph: {
    title: "My Awesome Page",
    description: "This is a demo of Next.js 13.4 Open Graph features.",
    url: "https://example.com",
    images: [
      {
        url: "https://example.com/og-image.jpg",
        width: 800,
        height: 600,
      },
    ],
  },
};
```

- 정적으로 내부 링크를 분석할 수 있다.

  - Next.js가 빌드 시 내부 링크를 정적으로 분석하여 잘못된 링크를 자동으로 감지한다.
  - next/link를 사용할 때 경로 오류나 누락된 페이지가 빌드 단계에서 경고로 표시된다.

# 11.7 Next.js 13 코드 맛보기

## getServerSideProps와 비슷한 서버 사이드 렌더링 구현해 보기

- 서버 컴포넌트에서 fetch를 수행하고, 별다른 cache 옵션을 주지 않는다.
- Next.js 13에서도 여전히 서버 사이드 렌더링과 비슷하게 서버에서 HTML로 미리 페이지를 렌더링해서 내려받는 것이 가능하다.
- 추가로 <script> 태그에 서버 컴포넌트와 클라이언트 컴포넌트의 데이터를 전달한다.

- 이후, 같은 라우트로 동적 라우팅을 하게 되면
  - 과거에서는 getServerSideProps의 실행 결과를 [id].json을 통해 받았다.
  - 직렬화된 서버, 클라이언트 컴포넌트 데이터를 받아 하이드레이션하는 것으로 변경되었다.

## getStaticProps와 비슷한 정적인 페이지 렌더링 구현해 보기

- 이전: getStaticProps를 이용하여 사전에 미리 생성 가능한 경로를 모으고, 미리 빌드하는 형식을 사용했다.
- generateStaticParams을 이용해 미리 생성 가능한 경로를 모으고, fetch에 별다른 옵션을 주지 않는다. 캐시된 페이지를 계속 활용하겠다는 뜻이다.
- 페이지를 갱신하고 싶을 수 있는데, 이때는 `fetch(url, { next: { revalidate: 0 } })`로 fetch를 호출하거나 `export const revalidate = 60;`으로 변수로 설정한다.
- 이 방식을 Incremental Static Regeneration(ISR)이라고 한다.
- 캐시된 페이지는 서버 액션에서 설명한 server mutation을 통해 갱신할 수도 있다.
- 블로그나 상품 소개와 같이 정적인 페이지를 빌드할 때 유용하게 사용할 수 있다.

## 로딩, 스트리밍, 서스펜스

- (1) 직접 <Suspense>로 감사 부분적으로 로딩을 보여주는 방법과 (2) loading.tsx를 활용하여 라우팅별로 로딩 상태를 보여줄 수 있다.
- 동작 방식의 차이는 없으며, Suspense가 조금 더 유연하게 로딩 범위을 제어할 수 있다.
- Suspense는 Promise를 리턴하는 컴포넌트에 사용할 수 있다.
- pending 상태라면 fallback UI를, resolved 상태라면 설정한 컴포넌트를 렌더링한다.
- Suspense로 감싸진 컴포넌트는 스트리밍으로 응답을 점전적으로 받으면서 렌더링한다.

```tsx
// 지연시키는 방법
async function delay() {
  await sleep(3 * 1000);
}
```

# 11.8 정리 및 주의사항

- 리액트 18의 서버 컴포넌트와 이를 지원하기 위한 Next.js 13의 변화를 살펴보았다.
- 서버 컴포넌트는 파일 단위로 use client를 경계로 서버와 클라이언트 컴포넌트를 명확하게 구분해야 하고, 나아가 라이브러리 또한 이 경계에 맞춰서 사용해야 하기 때문에 초기 개발 구조 설계 또한 바뀔 것이다.
- Next.js 13 마이그레이션 가이드, App Router 페이지의 React Essentials를 읽어보자.
- 리액트의 서버 컴포넌트는 이전에 없었던 완전히 새로운 패러다임이며, 앞으로 많은 변화를 가져올 것으로 보인다.
