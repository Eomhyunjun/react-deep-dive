775 - 812

# 12. 모든 웹 개발자가 관심을 가져야할 핵심 웹 지표

## 12.1 웹사이트와 성능

- 구글의 핵심 웹 지표(Core Web Vital)이라는 웹사이트 UX 향상을 위한 핵심 요소를 참조해보자.

## 12.2 핵심 웹 지표란?

- 핵심 웹 지표

  - 최대 콘텐츠풀 페인트 (LCP: Largest Contentful Paint)
  - 최초 입력 지연 (FID: First Input Delay)
  - 누적 레이아웃 이동 (CLS: Cumulative Layout Shit)

- 핵심 웹 지표는 아니지만 특정 문제 진단에 사용하는 지표

  - 최초 바이트까지의 시간 (TTFB: Time To First Byte)
  - 최초 콘텐츠풀 시간 (FCP: First Contentful Paint)

## 12.3 최대 콘텐츠풀 페인트(LCP)

### 12.3.1 정의

- 페이지가 처음으로 로드를 시작한 시점부터 뷰포트 내부에서 가장 큰 이미지 또는 텍스트를 렌더링하는 데 걸리는 시간

- 뷰포트 -> 사용자에게 현재 노출되는 화면
- '큰 이미지와 텍스트'

  - <img>
  - <svg> 내부의 <image>
  - poster 속성을 사용하는 <video>
  - url()을 통해 불러온 배경 이미지가 있는 요소
  - 텍스트와 같이 인라인 텍스트 요소를 표함하고 있는 블록 레벨 요소
    - 이 블록 레벨 요소에 <p>, <div> 등이 포함된다

- 뷰포트 영역 밖의 요소는 고려하지 않는다.

### 12.3.2 의미

- 사용자에게 있어 로딩이란 일단 뷰포트 영역에 보이는 부분을 기준으로 할 것이므로 뷰포트에 메인 콘텐츠가 화면에 완전히 전달되는 속도를 기준으로 하면 비슷하게 측정할 수 있을 것이다
- 사용자에게 페이지의 정보를 화면에 전달하는 속도를 객관적으로 판단하기 위한 지표로 만들어진 것이 바로 최대 콘텐츠풀 페인트 (LCP) 다

### 12.3.3 예제

- 최대 콘텐츠풀 페인트는 페이지 로딩에 따라 변화하는 지표다

  - 헤더 > 메뉴 > 이미지 영역 과 같이 로딩에 따라 변화될 수 있다

- 사용자 디바이스에 따라서 크키가 더 큰 리소스를 불러오면 LCP의 값이 달라질 수 있다

### 12.3.4 기준 점수

- LCP에서 좋은 점수는 2.5sec 내로 응답이 오는 것이다
  - 4초 이내로 응답이 온다면 보통, 그 이상이면 나쁨

### 12.3.5 개선 방안

- 이미지 대신 텍스트 사용

- 이미지 로딩 개선

  - <img> -> 이미지는 브라우저의 프리로드 스캐너에 의해서 먼저 발견되어 빠르게 요청이 일어난다. 병렬적으로 다운로드 일어나기 때문에 LCP에 쓰기 좋다.
  - <svg> -> 모든 리소스를 다 불러온 이후에 이미지를 불러온다. svg 내부의 img는 병렬적으로 다운로드 되지 않는다.
  - <video>의 poster -> poster는 사용자가 video 요소를 재상하거나 탐색하기 전까지 노출되는 요소다. img와 같은 성능이다. poster가 없는 경우 video를 로딩해 첫 프레임을 사용하기 때문에 LCP에 영향을 받을 것 같다면 꼭 poster를 넣어줘야한다.
  - background-image -> CSS에 있는 요소는 항상 느리다. 해당 리소스를 필요로하는 DOM을 그릴 준비가 될 때까지 요청을 뒤로 미루기 때문이다. 따라서 LCP에 좋지 못하다.

- 그 밖의 사항

  - 이미지 무손실 압축 -> 웹에서 서비스할 이미지는 가능한 무손실 압축해 최소한의 용량으로 서비스하는게 좋다.
  - loading=lazy 주의 -> 리소스를 중요하지 않음으로 표시하고 필요할 때만 로드하는 전략, <img>, <iframe> 등에 적용할 수 있지만 LCP의 이미지는 중요하지 않은 리소스로 분류하면 안된다.
  - fadein 과 같은 각종 애니메이션 -> 그냥 뜨는 것보다 fadeIn ease 10s와 같은걸 쓰면 LCP도 늦어진다.
  - 클라이언트에서 빌드하지 말 것 -> 프론트엔드에서 API의 응답을 필요로하면 그만큼 늦어진다.
  - 최대 콘텐츠풀 리소스는 직접 호스팅 -> 가능하다면 최대 콘텐츠풀 리소스는 같은 도메인에서 직접 호스팅하는 것이 좋다. 다른 출처에서 정제한 이미지를 가져오는 것은 최적화에 부정적이다.

## 12.4 최초 입력 지연(FID)

### 12.4.1 정의

- 사용자가 페이지와 처음 상호 작용할 때부터 해당 상호 작용에 대한 응답으로 브라우저가 실제로 이벤트 핸들러 처리를 시작하기까지의 시간을 측정합니다.

- 사용자가 얼마나 빠르게 웹페이지와의 상호작용에 대한 응답을 받을 수 있는지 측정하는 지표이다.

- 최초 입력 하나에 대해서만 판단한다.

### 12.4.2 의미

- 최초 입력 지연이란 화면이 최초에 그려지고 난 뒤, 사용자가 웹페이지에서 클릭 등 상호작용을 수행했을 때 메인 스레드가 이 이벤트에 대한 반응을 할 수 있을 때까지 걸리는 시간을 의미한다.

- 웹사이트 내부의 이벤트가 반응이 늦어지는 이유 -> 해당 입력을 처리해야 하는 브라우저의 메인 스레드가 바쁘기 때문이다. -> 바쁜 이유? 대규모 렌더링이 일어나고 있거나, 대규모 JS 파일을 분석하고 실행하는 등 다른 작업에 리소스를 할당 중이기 때문이다.

- 구글의 UX 분류 (RAIL)

  - Response: 사용자의 입력에 대한 반응 속도. 50ms 미만으로 이벤트를 처리할 것
  - Animation: 애니메이션의 각 프레임을 10ms 이하로 생성할 것
  - Idle: 유휴 시간을 극대화해 페이지가 50ms 이내에 사용자 입력에 응답하도록 할 것
  - Load: 5 초 이내에 콘텐츠를 전달하고 인터랙션을 준비할 것

- FID는 Response에 초점을 맞추고 있다.

### 12.4.3 예제

### 12.4.4 기준 점수

- FID에서 좋은 점수를 얻기 위해서는 100ms 이내로 응답이 와야 하며, 300ms 이내인 경우 보통, 그 이후의 경우에는 나쁨으로 처리된다

### 12.4.5 개선 방안

- FID에 가장 큰 영향을 미치는 메인 스레드에 이벤트를 실행할 여유를 줘서 개선한다.

- 실행에 오래 걸리는 긴 작업을 분리

  - 웹 페이지에서 해야하는 작업인지 확인
  - 긴 작업을 여러개로 분리 -> 크롬애서 50ms 이상 걸리면 오래 걸리는 작업이다.

- 자바스크립트 코드 최소화

  - 개발자 도구 > 커버리지 > 기록 버튼을 클리하고 웹페이지를 새로고침 > 커버리지 기록
  - 폴리필 -> 브라우저가 지원하지 않는 동작을 구현하고 집어 넣음. 크기가 크기때문에 꼭 필요한지 확인한다.

- 타사 자바스크립트 코드 실행의 지연

  - 외부 스크립트 코드가 잘 동작하는지 확인한다.
  - 주로 그렇게 중요한 자원이 아니기 때문에 async, defer를 이용해서 지연 불러오기를 하는 것이 좋다.

## 12.5 누적 레이아웃 이동(CLS)

### 12.5.1 정의

- 페이지의 생명주기 동안 발생하는 모든 예기치 않은 이동에 대한 지표를 계산하는 것

### 12.5.2 의미

- 최초 렌더링이 시작된 위치에서 만약 레이아웃의 이동이 발생한다면 누적 레이아웃 이동 점수로 기록하게 된다. 요소 추가가 다른 요소의 시작 위치에 영향을 미지면 레이아웃 이동으로 간주한다.

- 점수 계산 방법

  - 영향분율 -> 레이아웃 이동이 발생한 요소의 전체 높이와 뷰포트 높이의 비율
  - 거리분율 -> 레이아웃 이동이 발생한 요소가 뷰포트 대비 얼마나 이동했는지를 의미
  - 최종 점수 = 영향분율 \* 거리분율

### 12.5.3 예제

### 12.5.4 기준 점수

- CLS의 경우 0.1 이하인 경우 좋음, 0.25 이하인 경우 보통이며 그 외에는 나쁜 점수이다.

### 12.5.5 개선 방안

- 삽입이 예상되는 요소를 위한 추가적인 공간 확보

  - 요소의 크기나 위치가 바뀌는 것을 방지하기 위해서 useEffect 내부에서 요소에 영향을 미치는 작업, 뷰포트에 노출될 확률이 높은 작업을 최소화한다. 혹은 useLayoutEffect 사용 고려(로딩 지연 주의)
  - 스켈레톤 UI 처럼 공간을 미리 확보
  - SSR

- 폰트 로딩 최적화

  - 폰트로 발생하는 문제
    - FOUT (flash of unstyled text) -> 지정한 폰트가 보이지 않고 대체 기본 폰트로 보이고 있다가 뒤늦게 폰트가 적용되는 현상
    - FOIT (flash of invisible text) -> 지정한 폰트가 보이지 않고, 기본 폰트도 없어서 텍스트가 없는 채로 있다가 뒤늦게 폰트가 로딩되면서 페이지에 렌더링되는 현상
  - 해결 방법
    - <Link> 의 preload 사용 -> <Link> 요소의 rel=preload는 페이지에서 즉시 필요로 하는 리소스를 명시하는 기능이다. 리소스를 더 빠르게 사용할 수 있도록 준비한다.
    - font-family: optional: 폰트를 불러올 수 있는 방법은 크게 다섯 가지로 나뉜다.
      - auto( 기본값 ) -> 브라우저가 결정
      - block -> 폰트 로딩 전까지 렌더링 중단
      - swap -> FOUT 방식
      - fallback -> 100ms간 텍스트가 보이지 않고, 그 이후에 폴백 폰트로 렌더링한다. 3초 안에 폰트가 로딩되면 해당 폰트로 전환하고, 그렇지 않다면 폴백 폰트를 계속 사용한다.
      - optional -> falLback과 매우 유사하다. 3초 -> 0.1초

- 적절한 이미지 크기 설정
  - width, height 지정 -> 원하는 값을 지정하여 면적을 미리 할당

### 12.5.6 핵심 웹 지표는 아니지만 성능 확인에 중요한 지표들

- 최초 바이트까지의 시간 (Time To First Byte, TTFB)

  - 브라우저가 웹페이지의 첫 번째 바이트를 수신하는데 걸리는 시간

- 최초 콘텐츠 페인트 (First Contentful Paint, FCP)

  - 페이지가 로드되기 시작한 시점부터 페이지 콘텐츠의 일부가 화면에 렌더링될 때까지의 시간 (웹사이트 접속 후 뭐라도 뜨기 시작한 시점까지의 시간)
  - FCP는 1.8 초 이내에 이뤄진다면 좋음a, 3.0 초 이내는 보통, 그 이후는 나쁨

## 12.6 정리
