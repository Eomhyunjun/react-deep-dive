# 12장: 모든 웹 개발자가 관심을 가져야 할 핵심 웹 지표

- 단순 버그 없이 웹 서비스를 운영하는 것도 중요하지만 사용자가 쾌적하게 운영하는 것도 매우 중요

## 12.1 웹사이트와 성능

- 웹 사이트에 대기대하는 사항
  - 웹 사이트를 방문한 목적달성
  - 목적을 달성하기위한 빠른 시간
  - 보안 (개인정보)

2019년 Protent의 웹 사이트 성능과 사용자 경험 사이의 상관관계 조사에 따르면

- 1초내로 로딩되는 사이트는 5초 내로 로딩되는 사이트보다 전자상거래 전환율(실제 구매로 이어지는 고객의 비율)이 2.5배 더 높다
- 0 ~ 5초의 범위에서, 1초 로딩이 늦어질수록 전환율을 4.42%씩 떨어진다. 즉, 5초 이상 느려지면 전환율은 20% 가까이 떨어진다
- 페이지 로드 시간이 0 ~ 2초 사이인 페이지에서 가장 높은 전환율을 달성할 수 있다.

사용자 또한 성능에 매우 민감한 것으로 밝혀짐.

- 소비자의 70%는 페이지 속도가 온라인 커머스 사이트를 방문하는 데 영향을 미친다고 밝힘
- 절반 가까운 사람이 더욱 빠르게 로딩할 수 있다면 애니메이션과 동영상이 필요없다고 밝힘

구글에서의 통계(세계 최대 검색엔진이자 가장 많은 방문객을 보유한)

- 전체 웹 페이지를 표시하는 데 필요한 최적의 평균 리소스 요청 수는 50회 미만이다. (한 페이지를 로딩하는 데 50회 미만의 요청이 발생해야 한다)
- 평균적으로 웹 페이지 전체를 요청하는 데 15.3초가 걸림.
- 인간의 뇌와 신경계를 분석한 결과, 페이지 로드 시간이 1초에서 10초로 늘어날수록 모바일 사이트를 이탈할 확률이 123% 증가함.

개발자가 성능에 무심한 이유

- 개발자는 사용자 평균보다 성능이 좋은 기기를 사용해 성능 이슈를 대체로 느끼지 못한다.
- 성능 개선 작업은 쉽지도, 재밌지도, 작업 대비 성과가 크게 나지 않는다.

웹 사이트 성능은 어떻게 측정?

- 과거: 로딩 속도, 전환율 등 지엽적 판단
- 최근: 구글의 핵심 웹 지표(Core Web Vital)

## 12.2 핵심 웹 지표란?

- 구글에서 만든 지표 - 웹 사이트에서 사용자 경험을 위한 필수적인 지표

**핵심 웹 지표**

- 최대 컨텐츠풀 페인트(LCP: Largest Contentful Paint)
- 최초 입력 지연 (FID: First Input Delay)
- 누적 레이아웃 이동 (CLS: Cumulative Layout Shift)

**특정 문제 진단을 위한 지표**

- 최초 바이트까지의 시간 (TTFB: Time To First Byte)
- 최초 콘텐츠풀 시간 (FCP: First Contentful Paint)

## 12.3 최대 콘텐츠풀 페인트(LCP)

### 12.3.1 정의

- 페이지가 처음으로 로드한 시점부터 뷰포트 내부에서 가장 큰 이미지 또는 텍스트를 렌더링하는 데 걸리는 시간

**뷰포트**: 사용자에게 현재 노출되는 화면

**가장 큰 이미지 또는 텍스트 (가장 큰 요소로 고려되는 것)**

- <img>
- <svg> 내부의 <image>
- poster 속성을 사용하는 video
- url()을 통해 불러온 배경 이미지가 있는 요소
- 텍스트와 같이 인라인 텍스트 요소를 포함하고 있는 블록 레벨 요소
  - 이 블록 레벨 요소에는 <p>, <div> 등이 포함됨.

크기가 크다하더라도, 뷰포트 영역 밖의 요소는 고려되지 않음.

### 12.3.2 의미

- 측정 기준으로 DomContentLoaded 이벤트를 생각하기 쉽지만
  ⇒ 스타일시트, 이미지, 하위 프레임의 로딩을 기다리지 않는다는 제한이 있음

### 12.3.4 기준 점수

- 2.5초 내로 오는 것이 좋음
- 4초 보통
- 그 이상 나쁨

### 12.3.5 개선 방안

**텍스트는 언제나 옳다**

- 뷰포트 최대 영역에 이미지가 아닌 문자열을 넣는 것

**이미지를 어떻게 불러올 것인가**

아래의 순서대로 빠름 [\*\*`yceffort.kr`](http://yceffort.kr)\*\* 에서 제공하는 예제 페이지로 수행

1. img (picture)
   - 브라우저의 프리로드 스캐너에 의해서 발견되어 빠르게 요청이 일어남.
   - 프리로드 스캐너?
     - HTML 파싱을 차단하지 않고 이미지와 같이 빠르게 미리 로딩하면 좋은 리소스를 찾아 로딩하는 브라우저의 기능
   - img 내부의 리소스는 프리로드 스캐너가 HTML 파싱과 병렬적으로 처리하므로 빠르다.
2. 비디오 태그의 poster
   - poster는 사용자가 video 요소를 재생하거나 탐색하기 전에 노출되는 요소.
   - 이 또한 프리로드에 의해 조기 발견
   - 향후 poster가 없는 비디오 태그는 비디오를 실제로 로딩해 첫 프레임을 poster 리소스로 대체할 예정이라고 함. poster를 반드시 넣어주는 것이 좋음
3. 백그라운드 img
   - 모든 css에 있는 리소스는 항상 느림.
   - 브라우저가 필요로 하는 DOM을 그릴 준비가 될 때까지 리소스 요청을 뒤로 미루기 때문
4. svg내부의 img
   - 모든 리소스를 불러온 후, 이미지를 불러옴 (LCP에 악영향)

**그 밖에 조심해야할 사항**

- 이미지 무손실 압축: 가능한 무손실 형식으로 압축해 최소한의 용량으로 서비스하는 것이 좋음
- loading=lazy 주의: 리소스를 중요하지 않음으로 표시하고 필요할 때만 로드하는 전략. 중요하지 않은 이미지에만 적용하기
- fadein과 같은 각종 애니메이션: 애니메이션이 들어가면 당연히 느려짐
- 클라이언트에서 빌드하지 않기:
  - 최적의 시나리오 = 서버에서 빌드해온 HTML을 프리로드가 미리 읽어서 LCP를 낮추는 것
  - API 요청과 같은 useEffect가 필요한 경우 ⇒ 빌드된 채로 오는 것이 좋음
- 최대 콘텐츠풀 리소스는 직접 호스팅:
  - 일반적인 경우 Cloudinary 같은 이미지 최적화 서비스를 사용해 하나의 이미지에 대해 크기도 줄이고, 포멧도 변환하고, 압축해서 이미지를 관리하지만 다른 출처(origin)에서 정제한 이미지를 가져오는 것은 최적화에 좋지 않음
  - 이미 연결이 맺어진 현재 출처와는 다르게, 완전히 새로운 출처의 경우에는 네트워크 커넥션부터 다시 수행해야하기 때문.
  - loading=lazy의 경우와 마찬가지로 가능한 한 리소스는 직접 다루고 덜 중요한 리소스에 대해서만 이미지 최적화 서비스를 이용하는 것이 좋음

## 12.4 최초 입력 지연(FID)

### 12.4.1 정의

- 사용자가 페이지와 처음 상호 작용할 때부터 해당 상호 작용에 대한 응답으로 브라우저가 실제로 이벤트 핸들러 처리를 시작하기까지의 시간
- 최초의 입력 하나에 대해서만 판단함

### 12.4.2 의미

- 최초 입력이 늦다는 것 = 메인스레드가 바쁘다는 것

최초 입력에 해당하는 것?

- 클릭, 터치, 타이핑 등 사용자의 개별 입력 작업에 초점을 맞추고 측정함

구글이 정의하는 사용자 경험(RAIL)

1. Response: 사용자 입력에 대한 반응 속도, 50ms 미만으로 처리할 것
2. Animation: 각 프레임 10ms 이하로 생성할 것
3. Idle: 유휴 시간을 극대화해 페이지가 50ms 이내에 사용자 입력에 응답하도록 할 것
4. Load: 5초 이내에 콘텐츠를 전달하고 인터렉션을 준비할 것

### 12.4.3 예제

주의할 점:

- 이벤트가 실행되는 순간까지의 시간만 측정함
- 실행 시간을 측정하고 싶다면 Event Timing API를 사용하는 것이 좋음

### 12.4.4 기준 점수

- 좋음: 100ms 이내
- 보통: 300ms 이내
- 나쁨: 그 이상

### 12.4.5 개선 방안

**실행에 오래 걸리는 긴 작업을 분리**

- 메인 스레드를 오래 점유해야하는 긴 작업은 최초 입력 지연뿐만 아니라, 웹 페이지 전반에 악영향을 미침
- 오래걸리는 작업이 있다면
  - 꼭 웹페이지에서 해야 하는 작업인가 고민하기 - 서버에서!
  - 작업을 여러개로 분리하기
    - 크롬은 50ms 이상 걸리면 오래걸린다고 간주함
    - 당장 필요하지 않은 요소는 Suspense, lazy, dynamic import로 나중에 처리하기

**자바스크립트 코드 최소화**

- 필요 없는 요즘은 코드 번들러가 제거해주지만, 그래도 남아 있을 수 있음
- 크롬 개발자도구 → 점 세개 → 도구 더보기 → 커버리지 → 기록하기로 확인
- 사용되지 않는 코드 제거하고, 급하지 않은 코드는 뒤로 미루기

**폴리필 확인하기**

- 폴리필 크기가 제법 큼.
- 폴리필 넣기 전에 확인할 것
  - 폴리필이 필요한 환경인가?
    - 구형 브라우저를 지원하지 않는다면 대부분 필요없음
  - 꼭 필요한 폴리필인가?
    - 사용되는 곳이 몇 군데 되지 않는다면, 직접 코드를 작성해 구현하는 편이 좋을 수 있음
- 바벨같은 도구를 사용한다면 @babel/preset-env를 사용해 사용하고 있는 내용만 폴리필에 담을 수 있음 / SWC를 사용중이라면 알아서 제거해줌

**타사 자바스크립트 코드 실행 지연**

- 구글 애널리틱스나 Firebase와 같이 통계 집계를 위한 타사 스크립트를 사용하는 경우도 있음
- async와 defer를 이용해 지연 불러오기를 하는 것이 좋음

  - defer: 해당 리소스를 다른 리소스와 함께 병렬 다운로드 함. 다운로드 중에도 HTML 파싱 등의 메인 스레드 작업은 멈추지 않음. 다운 완료 후에도 실행은 페이지가 완전히 로딩된 이후 맨 마지막에 실행됨
  - async: defer와 같으나, 소스 다운로드 완료되면 바로 실행
  - 둘 다 없는 경우: script를 만나는 순간 다운로드 우선, 다운로드 후 코드 실행 (다른 작업은 다운로드 + 실행 끝날때까지 미뤄짐)

- 타사 자바스크립트는 가능하다면 defer로 아니라면 async로 지연하는 것이 좋다.
- 광고와 같이 사용자의 뷰포트 위치에 따라 불러와야 한다면 Intersection Observer를 이용해 뷰포트에 들어오는 시점에 불러오는 것이 좋음.
  - 광고는 회사에는 중요하지만, 어디까지나 사용자가 좋은 경험을 겪고 남아 있어야 유의미함.

## 12.5 누적 레이아웃 이동(CLS)

### 12.5.1 정의

- 로딩 끝난 줄 알고 클릭했는데 → 다른 요소가 나타나면서 클릭하려했던 요소 클릭 못하는 개빡치는 경우
- **누적 레이아웃 이동은** = 페이지의 생명주기 동안 발생하는 예기치 않은 이동에 대한 지표 계산을 의미

### 12.5.2 의미

- 뷰포트 내부에서만 측정
- 최초 렌더링이 시작된 위치에서 레이아웃의 이동이 발생한다면 점수로 기록
- 요소가 추가되어도 다른 요소의 시작 위치에 영향을 미치지 않으면 점수 기록 안됨
- 사용자 액션으로 발생한 이동도 점수 기록 안됨

**점수 계산에 포함되는 내용**

- 영향분율: 레이아웃 이동이 발생한 요소의 전체 높이와 뷰포트 높이의 비율
- 거리분율: 요소가 뷰포트 대비 얼마나 이동했는 지.

점수 = 영향분율 \* 거리분율

### 12.5.4 기준 점수

- 좋음: 0.1 이하
- 보통: 0.25 이하
- 나쁨: 그 외

### 12.5.5 개선 방안

**삽입이 예상되는 요소를 위한 추가적인 공간 확보**

- useEffect 내부에서 요소(특히 뷰포트 내의)에 영향을 미치는 작업은 최소화하는 것이 좋음.
- useLayoutEffect 훅 사용 검토도 해볼만 하다.
- 스켈레톤 UI로 미리 공간 확보하는 것도 좋음
- 서버 사이드 렌더링이 젤 좋음 ㅇㅈ?
- 동적인 컨텐츠는 가능한 최초 뷰포트에 영향을 미치지 않는 곳으로 미루는 것이 좋음

**폰트 로딩 최적화**

- 폰트로 인해 발생할 수 있는 문제

  1. FOUT(flash of unstyled text): HTML 문서에서 지정한 폰트가 보이지 않고 대체 폰트로 보이고 있다가 뒤늦게 적용되는 현상
  2. FOIT(flash of invisible text): HTML 문서에서 지정한 폰트가 보이지 않고, 기본 폰트도 없어서 텍스트가 없는 채로 있다가 뒤늦게 폰트가 로딩되면서 페이지에 렌더링되는 현상

- 폰트가 다운로드 되기 전에 텍스트를 노출하려한다면
  → 높이와 크기가 다른 기본 폰트를 기반으로 한 텍스트를 노출해서 혹은 텍스트를 노출하지 못해서 누적 레이아웃 이동이 발생할 수 있음.
- 사용자 기기의 기본 폰트와 다른 폰트로 웹 페이지를 보여주고 싶다면?
  - link의 preload 사용
    - link 요소의 rel=preload는 페이지에서 즉시 필요로 하는 리소스를 명시하는 기능
    - 웹 페이지 생명주기에서 초기에 불러와야하는 중요 리소스로 간주되어, 빠르게 준비해줌
    - 페이지의 렌더링을 가로막거나 레이아웃을 방해할 가능성이 줄어듦
  - font-family: potional 폰트를 불러올 수 있는 방법은 크게 다섯가지
    - auto: 브라우저가 폰트를 불러오는 방법을 결정
    - block: 폰트가 로딩되기 전까지 렌더링 중단.(최대 3초)
    - swap: FOUT 방식. 기본 폰트 적용 후 지정한 폰트 적용
    - fallback: 100ms간 텍스트가 보이지 않고, 그 이후 폴백 폰트로 렌더링 함. 3초 안으로 폰트가 로딩되면 → 해당 폰트로 전환. 그렇지 않으면 폴백 폰트 계속 사용
    - optional: fallback과 비슷. 0.1초 이내로 폰트가 다운로드 돼 있거나 캐시돼 있지 않다면 폴백 폰트 사용, 일정 기간 폰트 다운 못하면 → 폰트 다운 취소함.

**적절한 이미지 크기 설정**

- 이미지를 원본 비율로 보여주고 싶어, height: auto로 불러오면
  - 이미지의 가로 세로 비율이 일정해 최적의 이미지를 보여줄 수 있다는 장점
  - 하지만 누적 레이아웃 이동이 커짐
- width: 100%, height: auto와 함께 img 태그 인라인 스타일로 width, height 지정하기
  - width, height로 원하는 비율을 지정하면 → 브라우저가 이미지를 로딩하기 전에 적절한 비율을 계산해 이미지가 표시되는 만큼 미리 면적을 할당함. 브라우저 유저 에이전트 스타일시트(브라우저가 기본으로 제공하는 스타일 시트)에 포함된 aspect-ratio 속성 덕분.
- 뷰포트 너비에 맞춰 다른 이미지를 제공하는 경우, srcset 속성 사용하기
  - 가로 세로 비율이 같은, 크기가 다른 이미지를 미리 준비한 다음 상황에 맞게 이미지를 사용할 수 있도록 준비하면 됨.

## 12.6 핵심 웹 지표는 아니지만 성능 확인에 중요한 지표들

**최초 바이트까지의 시간 (TTFB: Time To First Byte)**

- 브라우저가 웹페이지의 첫 바이트를 수신하는데까지 걸리는 시간
- 600ms 이상 걸릴 경우 개선 필요
- 그 시간동안 빈 페이지가 뜨는 것을 의미

개선 하려면?

- **서버 사이드 렌더링 수행 시**
  - 로직 최적화
  - API 호출 최적화
- **방문객 나라와 가깝게 서버 위치 시키기**
- **리액트 서버 사이드 렌더링이라면?**
  - 스트리밍 API 활용하기

**최초 콘텐츠풀 시간 (FCP: First Contentful Paint)**

- 페이지가 로드되기 시작한 시점부터 페이지 콘텐츠의 일부가 화면에 렌더링될 때까지의 시간
- 1.8초 이내 굿, 3초 이내 보통, 그 이후 나쁨

개선하려면?

- TTFB 개선하기 → 뭐라도 다운돼야 렌더링 가능함
- 렌더링 가로막는 리소스 최소화: js나 css 같은 리소스 최소화 + 비동기 로드하기
- Above the Fold에 대한 최적화:
  - Above the Fold: 신문이 독자에게 제공됐을 때 가장 먼저 보이는 영역을 말함, 보통 신문이 반으로 접혀서 보이는 형태인데 그 영역을 말함
  - 웹에서는 스크롤을 하지 않아도 보이는 영역을 말함
  - lazy 로딩 + 스크립트에 의존해 요소가 렌더링 되는 것 막기
- 페이지 리다이렉트 최소화: 특정 페이지에서 다른 페이지로 리다이렉트 해야하는 경우. 사용자에게 보여주는 시간이 지연됨. → 리다이렉트는 없거나 최소한으로 유지
- DOM 크기 최소화: DOM이 크면 렌더링 시간 오래 걸림. 구글의 기준에 의하면 DOM 노드는 1500개 미만, 깊이는 32단계 정도까지만, 부모 노드는 자식 노드를 60개 정도만 가지고 있어야 함.
