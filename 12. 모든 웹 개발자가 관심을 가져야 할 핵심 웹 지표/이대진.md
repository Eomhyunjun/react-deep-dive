# 12. 모든 웹 개발자가 관심을 가져야 할 핵심 웹 지표

웹서비스의 성능을 객관적으로 평가할 수 있는 핵심 웹 지표에 대해 알아본다.

## 12.1 웹사이트와 성능

사용자는 웹사이트에서 3가지를 기대한다.

1. 방문 목적을 쉽게 달성해야 한다.
2. 목적 달성에 걸리는 시간이 짧아야 한다.
3. 개인 정보가 노출되는 등의 사고 없이 보안이 철저해야 한다.

웹사이트의 성능과 사용자 경험은 정비례한다. 이 성능은 어떻게 측정하는가? 구글의 핵심 웹 지표가 있다.

## 12.2 핵심 웹 지표(Core Web Vital)란?

- LCP, Largest Contentful Paint - 최대 콘텐츠풀 페인트
- FID, First Input Delay - 최초 입력 지연
- CLS, Cumulative Layout Shift - 누적 레이아웃 이동

아래 두 지표는 핵심은 아니지만 특정 문제를 진단하는 데 사용될 수 있다.

- TTFB: Time To First Byte - 최초 바이트까지의 시간
- FCP: First Contentful Paint - 최초 콘텐츠풀 시간

## 12.3 LCP

Largest Contentful Paint란 페이지가 처음 로딩을 시작한 시점부터 뷰포트 내부에서 가장 큰 이미지 혹은 텍스트를 렌더링하는 데 걸리는 시간을 말한다.

사용자에게 있어 로딩이란 일단 뷰포트 영역에 보이는 부분을 기준으로 하므로 뷰포트에 메인 콘텐츠가 화면에 완전히 전달되는 속도를 기준으로 한다면, 사용자는 페이지가 로딩이 완료됐다고 체감하는 시간과 매우 비슷하게 측정 가능하다.

LCP에서 좋은 점수는 해당 지표가 2.5초 내로 응답이 오는 것이다.

![image](https://github.com/user-attachments/assets/98e06080-469e-4b45-b5aa-3b33eeccd429)

### 12.3.5 개선 방안

LCP 예상 영역에 텍스트를 넣는 것이 가장 확실한 방법이다. 이미지를 아무리 최적화해도 텍스트 노출이 훨씬 더 빠르다. 따라서 가능한 해당 영역은 텍스트로 태우는 것이 좋다.

사용자들에게 더 강한 인상을 주기 위해 LCP 영역에 이미지를 사용하기를 원한다.
이미지는 어떻게 불러올 것인가?

```html
<! - - 1) img - >
<img src="lcp.jpg" ... />
<! - - 2) svg - - >
<svg xmlns="http://www.w3.org/1000/svg">
  <image href="lcp.jpg" />
</svg>
<!- 3) ( 비디오의 경우 ) vide.poster -->
<video poster="lcp.jpg"></video>
<! - - 4 ) background-image: url() - - >
<div style="background-image: url(lcp.jpg)">...</div>
```

![image 1](https://github.com/user-attachments/assets/d5732fa0-a08d-43a6-9c79-bcb52d52e25d)

![image 2](https://github.com/user-attachments/assets/7bbe83c3-70d9-4e29-ac73-91546a4e1c51)


- `<img>`: 브라우저 프리로드 스캐너에 의해 먼저 발견되어 빠르게 요청이 일어난다. 프리로드 스캐너는 HTML 파싱 단계에서 블로킹되지 않고 이미지처럼 미리 로딩하면 좋은 리소스를 먼저 찾아 로딩하는 브라우저 기능이다.
- `<svg>` 내부의 `<img>`: 프리로드 스캐너에 의해 발견되지 않아 병렬 다운로드가 일어나지 않는다. 지양.
- `<video>`의 poster: 포스터는 사용자가 비디오 요소를 재생, 탐색하기 전까지 노출되는 요소다. 프리로드 스캐너에 의해 발견되어 `<img>`같은 성능을 낸다. 향후 포스터가 없는 비디오는 비디오를 실제 로딩해 첫 프레임을 포스터 리소스로 대체할 예정이므로 video가 LCP에 영향을 받을 것 같으면 포스터를 넣는 것이 좋다.
- background-image: CSS 리소스는 항상 느리다. 해당 리소스를 필요로하는 DOM을 그릴 준비가 될 때까지 리소스 요청이 미뤄지기 때문에, LCP에도 좋은 영향을 끼치지 않는다.

### 이외 조심할 사항

- 이미지 무손실 압축 필요
- loading=lazy: 필요할 때만 로드하는 전략인데, LCP의 콘텐츠 이미지에는 사용하지 말자.
- fadein같은 각종 애니메이션은 지양할 것. 당연히 이미지가 바로 뜨는 것이 좋다.
- LCP 영역은 가능한 서버에서 빌드해올 것.
  `useEffect`같이 클라이언트에서 리액트 코드 파싱 후 API 요청을 보내어 응답을 받는 등의 결과를 LCP에 사용한다면 그만큼 늦어지게 된다.
- LCP 리소스는 가능한 직접 호스팅할 것. 외부 origin에서 이미지를 받아오는 경우는 내부 리소스와 비교하면 네트워크 연결부터 다시 수행해야 하며 여러모로 최적화에 좋은 영향을 끼치지 않는다.

## 12.4 FID

웹사이트의 로딩 시간만큼 중요한게 웹사이트의 반응 시간이다. 최초 입력 지연, First input delay는 사용자가 페이지와 처음 상호 작용할 때부터 해당 상호 작용에 대한 응답으로 브라우저가 실제로 이벤트 핸들러 처리를 시작하기까지의 시간을 측정한다.

웹사이트 내부의 이벤트 반응이 늦어지는 이유는 브라우저의 메인 스레드가 렌더링이나 JS 파일을 분석하고 실행하는 등의 작업을 수행하느라 바쁘기 때문이다. JS 실행 환경은 싱글 스레드이기 때문에 이벤트 리스너같은 다른 작업을 실행할 수 없다.

구글에서는 사용자 경험을 4가지로 분류해 정의한다. 이를 RAIL이라 한다.

- Response: 사용자 입력에 대한 반응 속도, 50ms 미만으로 이벤트 처리할 것 → FID
- Animation: 애니메이션 각 프레임을 10ms 이하로 생성할 것
- Idle: 유휴 시간을 극대화해 페이지가 50ms 이내에 사용자 입력에 응답하도록 할 것
- Load: 5초 이내에 콘텐츠를 전달하고 인터렉션을 준비할 것

![image 3](https://github.com/user-attachments/assets/1768f134-21db-4d50-9189-5eb84106e9bd)


![image 4](https://github.com/user-attachments/assets/a1784973-2af0-4188-8029-92e55a3d9c91)

<aside>
    
    ❓이거 어디서 봄? 봐보신 분?

</aside>

### 12.4.5 개선 방안

- 실행을 완료하는데 오래 걸리는 작업을 분리한다.
  개발자 도구 성능 탭에서 긴 작업은 빨간색 빗금이 쳐진다.
  ![image 4](https://github.com/user-attachments/assets/0f8b7418-7dc5-4ef4-bcae-88068350fb2d)
  
- JS 코드 최소화
  번들링을 거치더라도 경우에 따라 웹페이지를 불러오는 데 사용되지 않는 코드가 존재할 수 있다.
  이들은 급하지 않은 코드로 간주해 지연 로딩 기법을 통해 우선순위를 낮춰서 불러오는 것이 좋다.
  폴리필 또한 꼭 필요한 환경인지도 고려해봐야 한다.
- 타사 JS 코드 실행의 지연
  GA나 Firebase 같이 웹페이지 통계 집계를 위해 타사 스크립트를 삽입하는 경우가 있다. 대부분 웹 로드에 중요한 자원이 아니므로 `async` 혹은 `defer`를 이용해 지연 불러오기를 하는 것이 좋다.

## 12.5 CLS

누적 레이아웃 이동, cumulative layout shift는 페이지의 생명주기 동안 발생하는 모든 예기치 않은 이동에 대한 지표를 계산하는 것이다. 이것이 낮을수록 더 좋은 웹사이트다.

뷰포트 내부의 요소에 대해서만 측정한다. 최초 렌더링이 시작된 위치에서 만약 레이아웃의 이동이 발생하면 CLS 점수로 기록된다. 요소가 추가된다 하더라도 다른 요소의 시작 위치에 영향을 미치지 않았으면 CLS로 간주되지 않는다.

클라이언트에서 노출이 예상되는 부분을 HTML (스켈레톤)으로 자리를 잡아두는 것이 CLS에 큰 도움이 된다.

![image 5](https://github.com/user-attachments/assets/839688b5-4c1a-42de-878a-5e0fe23499dd)

### 12.5.5 개선 방안

- 삽입 예상 요소를 위한 추가 공간 확보
  대부분의 큰 CLS는 클라이언트에서 삽입되는 동적인 요소로 인해 발생한다. 스켈레톤 UI처럼 공간을 미리 확보하는 것도 좋다. 다만 해당 영역이 예상대로 나타나지 않는 케이스가 있다면 CLS를 피할 수 없다. 이럴 때 SSR이 가장 좋은 방법이다.
- 폰트 로딩 최적화
  - FOUT(flash of unstyled text): HTML 문서에서 지정 폰트가 아니라 대체 기본 폰트로 보이고 있다가 뒤늦게 적용되는 현상
  - FOIT(flash of invisible text): HTML 문서에서 지정 폰트가 아니고 대체 폰트도 없어서 텍스트가 안보이다가 뒤늦게 폰트가 로딩되면서 페이지에 렌더링되는 현상
    폰트는 각각 너비와 높이가 있기 때문에 CLS가 발생할 수 있다. 따라서 다른 폰트를 사용한다면 아래와 같은 점을 유념해야 한다.
  - `<link>`의 preload 사용: `rel=preload`는 즉시 필요한 리소스를 명시하며, 이것으로 스타일이나 폰트를 지정하면 페이지의 렌더링을 막거나 CLS를 줄일 수 있다.
  - `font-family: optional`: 폰트를 불러올 수 있는 방법은 다섯가지다.
    - auto(기본): 브라우저가 폰트 로딩 방법을 결정
    - block: 폰트 로딩 전까지 렌더링 중단(max 3초)
    - swap: FOUT 방식
    - fallback: 100ms간 텍스트가 보이지 않고, 이후 폴백 폰트로 렌더링한다. 3초안으로 폰트로 로딩되면 해당 웹 폰트로 전환, 그렇지 않으면 폴백 폰트를 계속 사용
    - optional: fallback과 유사, 0.1초 이내로 폰트가 다운로드되거나 캐시되어있지 않다면 폴백 폰트를 사용한다. 특이한 점은 브라우저가 네트워크 상태를 파악해 일정 기간동안 퐅르를 다운로드 못하면 연결을 취소한다.
- 적절한 이미지 크기 설정
  모바일 기기의 발전으로 반응형 웹사이트를 추구하기 시작했다.
  `jsx
img {
  width: 100%;
  height: auto;
}
`

  이미지가 완전히 다운로드 되기 전까지는 높이를 알 수 없기 때문에 이 경우 CLS가 커진다.

![image 6](https://github.com/user-attachments/assets/2a1aa717-b1e9-4761-b1de-0ac07007bae8)

  - width, height를 지정하는 것이 가장 좋은 방법이다. 이 경우 브라우저가 이미지 로딩 전에 적절한 가로세로 비율을 계산해 이미지가 표시되는 면적을 할당해준다. aspect-ratio 속성 덕분이다. 브라우저의 유저 에이전트 스타일시트에 포함되있으며 이미지의 가로세로 비율을 자동으로 맞춰준다.
  - 만약 사용자 뷰포트에 맞춰 다른 이미지, 즉 반응형 이미지를 사용하고 싶다면 `srcset` 속성을 사용하는 것이 좋다. 가로세로 비율이 똑같지만 크기가 다른 여러 이미지를 준비해 둔 다음 브라우저가 상황에 맞게 이미지를 사용할 수 있도록 준비하면 된다.

    ```html
    <img
      width="1000"
      height="1000"
      src="image-1000.jpg"
      srcset="image-1000.jpg 1000w, image-2000.jpg 2000w, image-3000.jpg 3000w"
      alt="이미지"
    />
    ```

      <aside>
      
        ❓ SVG 이미지를 이용하면 다른 이미지 여러개를 사용하지 않아도 될듯?!

      </aside>

### 12.5.6 핵심 웹 지표는 아니지만 성능 확인에 중요한 지표들

- TTFB
  최초 바이트까지의 시간, Time To First Byte는 브라우저가 웹페이지의 첫 번째 바이트를 수신하는데 걸리는 시간이다. 최초의 응답이 오는 바이트까지 얼마나 걸리는지를 측정한다. 600ms 이상 걸릴 경우 개선이 필요하다.
  SSR 앱에서 주의 깊게 봐야한다. 최초 페이지를 만들기 위해 서버에서 작업을 어느정도 수행하기 때문에 서버에서 첫 HTML을 만들기 위해 해야 하는 작업이 많거나 느릴수록 TTFB 시간이 늘어난다.
  이를 개선하기 위해선, SSR의 경우 로직을 최적화해 페이지를 최대한 빨리 준비시켜야 한다.
  웹페이지의 주 방문객의 국적을 파악해 최대한 가깝게 서버를 위치시킨다.
- FCP
  최초 콘텐츠풀 페인트, First Contentful Paint란 페이지 로드 시작 시점부터 페이지 콘텐츠 일부가 화면에 렌더링될 때까지의 시간을 측정한다.


![image 8](https://github.com/user-attachments/assets/a2d77df1-91dc-4080-bea3-8070cb06ba3a)
