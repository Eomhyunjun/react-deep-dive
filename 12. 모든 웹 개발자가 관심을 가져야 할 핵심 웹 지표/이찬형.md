# 12.1 웹 사이트와 성능

- 사용자가 웹 사이트에 접속했을 때 공통적으로 기대하는 사항
  - 웹 사이트를 방문한 목적 달성
  - 첫 번째 목적을 달성하는데 걸리는 시간이 짧아야 함
  - 개인정보 누출 등 보안이 철저해야 함
- 최신 기술을 사용하더라도 기대하는 바를 충족하지 못한다면 불편함을 느낄 것이다. 반대로 오래된 기술이라도 기대하는 바를 충족한다면 불편함을 느끼지 않을 것이다.
- 웹 사이트의 성능이 미치는 영향
  - 1초 내로 로딩되는 사이트는 5초 내로 로딩되는 사이트보다 전환율이 2.5배 높다.
  - 0 ~ 5초에서 1초 로딩이 늦어질수록 전환율은 4.42%씩 떨어진다.
  - 페이지 로드 시간이 0 ~ 2초인 페이지에서 가장 높은 전환율을 달성할 수 있다.
  - 소비자의 70%는 페이지 속도가 온라인 커머스 사이트 방문에 영향을 미친다고 응답하였다.
  - 약 50%의 사용자는 더욱 빨리 로딩할 수 있다면 애니메이션과 동영상이 필요없다고 응답하였다.
  - 한 페이지를 로딩하는데 50회 미만의 요청이 발생해야 한다.
  - 평균적으로 웹 페이지 전체를 요청하는데 15.3초가 걸린다.
- 기기의 성능과 네트워크 속도가 빨라졌음에도 불구하고, 여전히 대다수의 방문객은 속도에 민감하며 느린 속도에 대해 불만이다. 과거보다 더 많은 정보를 제공해야 하기 때문이다.
- 방문객들은 웹 사이트가 빠르길 기대한다. 그다지 인내심이 많이 없다.
- 개발자들은 성능에 크게 관심이 없어보인다.
  - 개발자의 기기는 일반 사용자의 기기보다 평균적으로 성능이 뛰어나다.
  - 성능 개선 작업은 쉽지도, 재밌지도, 눈에 띄는 성능 향상을 기대하기 어렵기 때문이다.
- 하지만 웹 사이트 개발자라면 성능에도 주의를 기울여야 한다. 이 또한 개발자의 책임이며, 조직이 이루고자 하는 목표와 직결된다고 봐도 무방하다.
- 어떻게 측정?
  - 과거에는 웹사이트의 로딩 속도, 전환율 등 지엽적으로만 판단했다.
  - 요즘에는 Core Web Vital이라는 측정 항목이 등장했다.

# 12.2 핵심 웹 지표란?

- 핵심 웹 지표(Core Web Vitals)는 구글에서 만든 웹 사이트에서 뛰어난 사용자 경험을 제공하는데 필수적인 지표를 말한다.
- 과거에는 뚜렷한 표준이나 측정 방법이 정해져 있지 않아 일관성이 부족하였다.

- 핵심 지표
  - Largest Contentful Paint(LCP): 최대 콘텐츠풀 페인트
  - First Input Delay(FID): 최초 입력 지연
  - Cumulative Layout Shift(CLS): 누적 레이아웃 이동
- 추가 지표
  - Time to First Byte(TTFB): 최초 바이트까지의 시간
  - First Contentful Paint(FCP): 최초 콘텐츠풀 시간

## 구글의 사용자 경험 분류

- Response: 사용자의 입력에 대한 반응 속도를 50ms 이내로 유지
- Animation: 애니메이션의 각 프레임을 10ms 이내로 렌더링
- Idle: 유휴 시간을 극대화해 페이지가 50ms 이상 반응하지 않는 시간을 최소화
- Load: 5초 이내에 컨텐츠를 전달하고 인터랙션을 가능하게 함

# 12.3 최대 콘텐츠풀 페인트(LCP)

## 정의

- Largest Contentful Paint
- 페이지가 처음으로 로드를 시작한 시점부터 퓨초인트 내부에서 가장 큰 이미지 또는 텍스트를 렌더링하는 데 걸리는 시간
- 즉, 사용자에게 중요한 콘텐츠를 얼마나 빠르게 노출하는지를 측정한다.
- 뷰포트?
  - 사용자에게 현재 노출되는 화면
  - 기기에 의존하므로 뷰포트 크기는 기기마다 다르다.
  - 뷰포트 영역 밖으로 넘치는 요소가 있다면 해당 영역은 무시된다.
- 큰 이미지와 텍스트?
  - <img>
  - <svg> 내부의 <image>
  - poster 속성을 사용하는 <video>
  - url() 함수를 사용하는 CSS background-image
  - 인라인 텍스트 요소를 포함하고 있는 블록 요소
- 즉, LCP는 사용자의 기기가 노출하는 뷰포트 내부에서 가장 큰 영역을 차지하는 요소가 렌더링되는 데 얼마나 걸리는지를 측정하는 지표이다.
- 뷰포트 내에서 가장 큰 영역을 차지하는 요소가 바뀔수도 있음에 유의해야 한다.

## 의미

- DOMDocumentLoaded 이벤트: HTML 문서를 완전히 로드하고 파싱한 시점
- 이 이벤트가 호출되었다고 사용자 입장에서 페이지가 완전히 로드된 것은 아니다. DOMDocumentLoaded 이벤트는 스타일시트, 이미지, 하위 프레임임의 로딩까지 기다리지 않기 때문이다.
- 즉, 대부분이 이미지로 이루어진 뷰포트라면, DOMDocumentLoaded 시점과 사용자 입장에서의 로드 시점이 차이가 날 수 있다.
- 그래서 뷰포트에서 가장 큰 영역을 차지하는 요소가 렌더링되는 시점을 사용자 입장에서의 로드 시점이라고 정의한다.

## 기준 점수

- Good: 2.5초 이내
- Needs Improvement: 2.5초 ~ 4초
- Poor: 4초 이상

## 개선 방안

### 텍스트는 언제나 옳다

- 해당 영역을 텍스트로 채우는 방법이다.

### 이미지는 어떻게 불러올 것인가?

- 만약 이미지를 사용해야 한다면, 4가지 방법이 있다

```html
<img src="image.jpg" />
<svg xmlns="http://www.w3.org/2000/svg">
  <image href="image.jpg" />
</svg>
<video poster="image.jpg" />
<div style="background-image: url(image.jpg)"></div>
```

1. <img> 태그를 사용하는 방법
   - 브라우저의 프리로드 스캐너에 의해 발견되어 빠르게 요청이 일어난다.
   - 즉, HTML 파싱이 완료되지 않더라도 프리로드 스캐너가 병렬적으로 리소스를 다운로드한다.
2. <svg> 내부의 <image> 태그를 사용하는 방법
   - 다른 리소스를 다 불러온 이후에 이미지를 불러오기 시작한다.
   - 즉, 프리로드 스캐너에 의해 발견되지 않는다.
3. <video> 태그의 poster 속성을 사용하는 방법
   - 비디오가 재생되기 전에 노출되는 요소이다.
   - 프리로드 스캐너에 의해 발견되어 빠르게 요청이 일어난다.
   - 비디오가 LCP에 영향을 받을 것 같다면 poster 속성을 사용하는 것이 좋다.
4. CSS background-image 속성을 사용하는 방법
   - 브라우저가 해당 리소스를 필요로 하는 DOM을 그릴 준비가 될 때까지 리소스 요청을 뒤로 미룬다.
   - LCP가 중요한 리소스에는 사용하지 않는 것이 좋다.

- 결론적으로 1번, 3번 방법이 가장 좋다.

### 그 밖에 고려해야 할 사항

- 이미지는 가능한 무손실 형식으로 합축해 최소한의 용량으로 전송해야 한다.
- loading=lazy 속성은 리소스를 중요하지 않음으로 표시하여, 필요할 때만 로드하는 전략이다. LCP가 중요한 컨텐츠에는 사용하지 않는 것이 좋다.
- fadein과 같은 애니메이션 효과는 LCP를 악화시킨다.
- useEffect 내부에서 LCP 영역을 노출하게 되면, LCP가 영향을 받을 수 있다. 서버 사이드 렌더링을 사용한다면, 서버에서 미리 빌드된 채로 오는 것이 좋다.
- LCP 리소스는 같은 도메인에서 가져오는 것이 좋다. 다른 도메인에서 가져오는 것은 추가적인 DNS 조회와 TCP 연결이 필요하기 때문이다. 덜 중요한 리소스에 대해서만 이미지 최적화 서비스를 사용하는 것이 좋다.

# 12.4 최초 입력 지연(FID)

## 정의

- First Input Delay
- 사용자가 최초로 페이지와 상호 작용할 때(e.g. 버튼 클릭)부터 상호 작용에 대한 응답으로 실제로 이벤트 핸들러 처리를 시작하기까지의 시간
- 즉, 사용자가 얼마나 빠르게 웹 페이지와의 상호작용에 대한 응답을 받을 수 있는지 측정하는 지표이다.
- 모든 입력이 아니고 최초의 입력에 대한 지연을 측정한다.
- 이벤트 핸들러가 완료되는 시간까지가 아니라 이벤트 핸들러가 호출되는 시점까지 측정한다.
- e.g. 수강 신청 페이지에서 엄청 큰 트래픽이 몰릴 때, 클릭이나 타이핑이 되지 않아 아무런 작업을 하지 못하는 상태

## 의미

- 웹 사이트 내부의 이벤트가 반응이 늦어지는 이유는?
  - 자바스크립트 실행 환경은 단일 스레드이고, 이 스레드가 바쁘기 때문이다.
  - 바쁜 이유는? 대규모 렌더링이 일어나고 있거나, 자바스크립트 파일을 분석하고 실행하는 데 시간이 걸리기 때문이다.
- 입력에 해당하는 것은? 클릭, 터치, 타이핑 등 사용자의 개별 입력 작업에 초점을 맞추고 측정한다(스크롤이나 핀치 투 줌은 애니메이션으로 분류한다).
- 구글 사용자 경험(RAIL)의 Response 부분에 해당한다.

## 예제

- 버튼을 클릭한 시점(2000ms)과 이벤트가 발생한 시점(2600ms)
- 클릭 이벤트가 발생한 시점에 메인 스레드가 다른 작업을 하고 있었다. 즉, 메인 스레드가 작업 중인 시점에 클릭 이벤트가 발생했다.

## 기준 점수

- Good: 100ms 이내
- Needs Improvement: 100ms ~ 300ms
- Poor: 300ms 이상

## 개선 방안

- 메인 스레드에 이벤트를 실행할 여유를 줘야 한다.

### 실행에 오래 걸리는 긴 작업을 분리

- FID 뿐만 아니라 웹 페이지 전반에 악영향을 미친다.
- 성능 탭에서 CPU 성능을 제한하여 열악한 기기로 테스트하는 것과 비슷한 환경을 만들 수 있다.
- 꼭 웹 페이지에서 해야 하는 작업인가? 서버로 옮겨서 처리할 수 있는 작업인가?
- 여러 작업으로 분리하기: 당장 필요하지 않은 리소스를 나중에 불러오는 것도 포함된다. 리액트의 Suspense, lazy 혹은 Next.js의 dynamic을 이용할 수 있다.

### 자바스크립트 코드 최소화

#### 커버리지

- 번들러가 필요 없는 코드를 제거해 준다고 하더라도, 여전히 경우에 따라 웹 페이지를 불러오는 데 사용되지 않는 코드가 있을 수 있다.
- 커버리지 탭에서 사용되지 않는 코드를 확인할 수 있다.
- 사용되지 않는 코드를 삭제하는 것은 위험할 수 있으므로, 지연 로딩 방식을 사용해 우선순위를 낮춰서 불러오는 것이 좋다.

#### 폴리필

- 브라우저에서 지원하지 않는 기능을 직접 구현한 코드. 최신 자바스크립트 문법을 지원하지 않는 구형 브라우저에서 사용하기 위해 사용된다.
- 폴리필은 생각보다 용량이 크다.
- 폴리필을 사용하기 전에 반드시 확인하자
  1.  폴리필이 필요한 환경인가? 애플리케이션에서 구형 브라우저를 지원하지 않는다면, 폴리필을 제거하자.
  2.  꼭 필요한 폴리필인가? 자주 사용되지 않는 폴리필은 직접 구현하자.
- @babel/preset-env, SWC 등을 사용하면 자동으로 사용하는 폴리필만 번들에 포함시키기 때문에 편하다.

### 타사 자바스크립트 코드 실행의 지연

- Google Analytics나 Firebase와 같이 통계 집계를 위해 타사 스크립트를 넣는 경우
- <script> 태그에서 async, defer 속성을 사용하면 된다. 이 속성을 사용하게 되면, 스크립트를 병렬로 다운로드한다. 하지만 실행 시점이 다르다.
  - 속성 없음: HTML 파싱 중단 후 다운로드, 실행 -> HTML 파싱 재개 (완전 동기)
  - async: 다운로드가 완료되면 즉시 실행. 실행 시 HTML 파싱이 중단 
  - defer: HTML 파싱이 완료된 후 마지막에 실행
- 광고와 같이 뷰포트 위치에 따라 불러와야 하는 컴포넌트라면 Intersection Observer API와 lazy를 사용해 뷰포트에 들어오는 시점에 불러오는 것이 좋다.

# 12.5 누적 레이아웃 이동(CLS)

## 정의

- Cumulative Layout Shift
- 모든 예기치 않은 이동에 대한 지표를 계산하는 것이다.
- 낮을수록 좋은 지표이다.
- LCP와 마찬가지로 뷰포트 밖의 요소에 대해서는 측정하지 않는다.

## 의미

- 과거의 웹 사이트는 제공하는 정보가 한정적이었다. 단순히 서버에서 완성된 HTML과 자바스크립트를 다운로드받아 브라우저에서 보여주면 된다.
- 하지만 현재는 리액트의 도움으로 동적인 웹 사이트를 만들 수 있다. 예를 들어, useEffect 내부에 비동기 요청 후에 UI를 변경하는 작업이 있는 경우 사용자가 페이지를 보는 중간에 UI가 변경될 수 있다.
- 요소가 추가되었다고 CLS가 높아지는 것은 아니다. 요소가 추가되었을 때, 그 요소가 추가되기 전에 있던 요소들이 이동하는 것이다.
- 사용자가 아무런 동작을 하지 않았음에도 불구하고 레이아웃 이동이 발생하는 경우만 해당한다.
- 점수 = 영향분율 \* 거리분율

## 예제

- CLS는 기기의 크기에 따라 점수가 다르게 측정될 수 있다.
- 보통 뷰포트의 높이가 더 작은 기기에서 더 낮은 점수를 받는다.(CLS를 발생시키는 요소의 크기가 동일하다는 가정 하)
- 하지만 불편함을 겪는다는 사실은 결국 똑같다.
- 대부분의 서비스들은 스켈레톤 UI를 사용하여 페이지 레이아웃을 고정시켰다. 로딩이 완료되면 스켈레톤 UI를 없애고 실제 컨텐츠를 보여준다.
- 유튜브에서는 광고가 필요한지가 클라이언트에서 결정되기 때문에, 갑자기 위에서 div가 나타나면서 컨텐츠를 밀어냈고 CLS가 발생했다.
- 미리 노출이 예상되는 부분을 HTML로 자리 잡아 두는 것(e.g. 스켈레톤 UI)이 CLS 지표에 도움이 된다는 것을 알았다.
- 사용자는 미리 노출이 예상되는 부분을 예측할 수 있다는 장점이 있다.
- 물론 광고처럼 동적으로 결정되는 요소까지 예측해서 서버에서 렌더링하는 것도 방법이 될 수 있지만, 추가적인 부담이 될 수 있기 때문에 신중하게 결정해야 한다.

## 기준 점수

- Good: 0.1 이내
- Needs Improvement: 0.1 ~ 0.25
- Poor: 0.25 이상

## 개선 방안

### 삽입이 예상되는 요소를 위한 추가적인 공간 확보

- 대부분의 큰 CLS는 클라이언트에서 삽입되는 동적인 요소로 인해 발생한다.
- useEffect 내부에서 요소를 추가하는 작업을 최소화한다.
- useLayoutEffect를 사용하여 렌더링 전에 요소를 동기적으로 추가하는 작업을 수행한다. 하지만 동기적인 작업이기 때문에, 전체 작업에 영향을 미칠 수 있음에 유의해야 한다.
- 스켈레톤 UI처럼, 동적으로 뜰 것으로 예상되는 공간을 미리 확보해둔다.
- 서버 사이드 렌더링을 이용하여 서버에서 렌더링된 페이지를 클라이언트에게 전달한다. 그러나 타사 스크립트를 사용하는 경우에는 서버 사이드 렌더링을 사용할 수 없다.
- 가능한 한 최초 뷰포트에 영향을 미치지 않는 곳으로 미뤄두는 것이 좋다(회피).

### 폰트 로딩 최적화

- 폰트 또한 레이아웃이동을 일으키는 원인 중 하나이다. 폰트로 인해 발생할 수 있는 문제는 다음과 같다.
  1.  Flash of Unstyled Text: 대체 기본 폰트로 렌더링된 후, 실제 폰트로 교체되는 현상
  2.  Flash of Invisible Text: 텍스트가 보이지 않다가, 실제 폰트가 적용된 텍스트가 보이는 현상
- FOUT는 폰트가 교체되면서, FOIT는 텍스트가 렌더링되면서 CLS가 발생할 수 있다.
- 최적화를 하는 방법은 다음과 같다.
  1. <link>의 rel=preload 속성을 사용하여 폰트를 미리 로드한다.
  2. font-family에서 폰트를 불러오는 방법을 설정한다
     - block(폰트가 로드될 때까지 렌더링을 차단)
     - swap(FOUT; 폰트가 로드될 때까지 기본 폰트로 렌더링 로드되면 교체)
     - fallback(폰트가 로드될 때까지 기본 폰트로 렌더링 로드되면 교체, 3초 안에 폰트가 로드되지 않으면 기본 폰트를 유지)
     - optional(fallback과 유사하나, 폰트를 다운로드하지 못하면 취소)
- CLS를 줄이기 위해서는 두 가지 방법을 조합하여 사용하는 것이 좋다.
- 즉, 폰트를 preload로 미리 다운로드하고 빠르게 다운로드에 실패했다면 다음을 기약하고 기본 폰트를 노출하는 것이다.

### 적절한 이미지 크기 설정

```CSS
img {
	width: 100%;
	height: auto;
}
```

- 너비는 기기의 너비대로, 높이는 기기가 아니라 이미지의 비율에 맞게 설정한다.
- 그러나 CLS가 커지는 결과를 낳는다. 높이는 이미지가 다운로드되기 전에는 알 수 없기 때문에 높이의 변화가 발생하기 때문이다.

```HTML
<img src="image.jpg" width="1600" height="900" />
```

- 이미지의 크기를 미리 설정하면, 이미지가 로드되기 전에 이미지의 크기를 알 수 있기 때문에 CLS가 줄어든다.
- 반응형 이미지를 사용하고 싶다면, srcset 속성을 사용한다.(각각은 ,로 구분되어야 하며 너비를 알려주는 w를 사용해야 한다)

# 12.6 기타 지표들

## 최초 바이트까지의 시간(TTFB; Time to First Byte)

- 브라우저가 웹 페이지의 첫 번쨰 바이트를 수신하는데 걸리는 시간
- 즉, 페이지를 요청했을 때부터 최초의 응답이 오는 바이트까지 얼마나 걸리는지 측정하는 지표
- 600ms 이내로 유지하는 것이 좋다.
- 서버 사이드 렌더링을 사용하고 있다면
  - getServerSideProps나 async 함수 컴포넌트 실행 시간을 최적화할 필요가 있다.
  - 사용자가 한국인이 대부분이라면 ap-noretheast-2를 사용하여 시간을 최소화한다.
  - renderToNodeStream 등의 스트리밍 API를 사용한다.

## 최초 콘텐츠풀 페인트(FCP; First Contentful Paint)

- 페이지가 로드되기 시작한 시점부터 페이지 콘텐츠의 일부가 화면에 렌더링될 때까지 걸리는 시간
- LCP와 비슷하지만, LCP는 가장 큰 콘텐츠가 렌더링되는 시간이고, FCP는 첫 번째 콘텐츠가 렌더링되는 시간이다.
- 여기에서도 컨텐츠는 이미지나 텍스트 등을 말한다.
- 지표
  - Good: 1.8초 이내
  - Needs Improvement: 1.8초 ~ 3.0초
  - Poor: 3.0초 이상
- 개선 방안
  - TTFB를 줄이는 것이 FCP를 줄이는 데 도움이 된다.
  - CSS나 자바스크립트같이 렌더링을 가로막는 리소스를 최소화하고 비동기적으로 로드하도록(preload, async, defer 등..) 해야 한다.
  - lazy loading을 피한다.
  - 페이지 리다이렉트를 최소화한다.
  - DOM 크기를 최소화한다.
